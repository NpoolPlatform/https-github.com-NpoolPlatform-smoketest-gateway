// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/cond"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/module"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/planrelatedtestcase"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/testcase"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/testplan"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCond                = "Cond"
	TypeModule              = "Module"
	TypePlanRelatedTestCase = "PlanRelatedTestCase"
	TypeTestCase            = "TestCase"
	TypeTestPlan            = "TestPlan"
)

// CondMutation represents an operation that mutates the Cond nodes in the graph.
type CondMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	cond_type         *string
	test_case_id      *uuid.UUID
	cond_test_case_id *uuid.UUID
	argument_map      *string
	index             *uint32
	addindex          *int32
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Cond, error)
	predicates        []predicate.Cond
}

var _ ent.Mutation = (*CondMutation)(nil)

// condOption allows management of the mutation configuration using functional options.
type condOption func(*CondMutation)

// newCondMutation creates new mutation for the Cond entity.
func newCondMutation(c config, op Op, opts ...condOption) *CondMutation {
	m := &CondMutation{
		config:        c,
		op:            op,
		typ:           TypeCond,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCondID sets the ID field of the mutation.
func withCondID(id uuid.UUID) condOption {
	return func(m *CondMutation) {
		var (
			err   error
			once  sync.Once
			value *Cond
		)
		m.oldValue = func(ctx context.Context) (*Cond, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cond.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCond sets the old Cond of the mutation.
func withCond(node *Cond) condOption {
	return func(m *CondMutation) {
		m.oldValue = func(context.Context) (*Cond, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CondMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CondMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cond entities.
func (m *CondMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CondMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CondMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cond.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CondMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CondMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CondMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CondMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CondMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CondMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CondMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CondMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CondMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CondMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CondMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CondMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CondMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CondMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CondMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCondType sets the "cond_type" field.
func (m *CondMutation) SetCondType(s string) {
	m.cond_type = &s
}

// CondType returns the value of the "cond_type" field in the mutation.
func (m *CondMutation) CondType() (r string, exists bool) {
	v := m.cond_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCondType returns the old "cond_type" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldCondType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondType: %w", err)
	}
	return oldValue.CondType, nil
}

// ClearCondType clears the value of the "cond_type" field.
func (m *CondMutation) ClearCondType() {
	m.cond_type = nil
	m.clearedFields[cond.FieldCondType] = struct{}{}
}

// CondTypeCleared returns if the "cond_type" field was cleared in this mutation.
func (m *CondMutation) CondTypeCleared() bool {
	_, ok := m.clearedFields[cond.FieldCondType]
	return ok
}

// ResetCondType resets all changes to the "cond_type" field.
func (m *CondMutation) ResetCondType() {
	m.cond_type = nil
	delete(m.clearedFields, cond.FieldCondType)
}

// SetTestCaseID sets the "test_case_id" field.
func (m *CondMutation) SetTestCaseID(u uuid.UUID) {
	m.test_case_id = &u
}

// TestCaseID returns the value of the "test_case_id" field in the mutation.
func (m *CondMutation) TestCaseID() (r uuid.UUID, exists bool) {
	v := m.test_case_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseID returns the old "test_case_id" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldTestCaseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseID: %w", err)
	}
	return oldValue.TestCaseID, nil
}

// ClearTestCaseID clears the value of the "test_case_id" field.
func (m *CondMutation) ClearTestCaseID() {
	m.test_case_id = nil
	m.clearedFields[cond.FieldTestCaseID] = struct{}{}
}

// TestCaseIDCleared returns if the "test_case_id" field was cleared in this mutation.
func (m *CondMutation) TestCaseIDCleared() bool {
	_, ok := m.clearedFields[cond.FieldTestCaseID]
	return ok
}

// ResetTestCaseID resets all changes to the "test_case_id" field.
func (m *CondMutation) ResetTestCaseID() {
	m.test_case_id = nil
	delete(m.clearedFields, cond.FieldTestCaseID)
}

// SetCondTestCaseID sets the "cond_test_case_id" field.
func (m *CondMutation) SetCondTestCaseID(u uuid.UUID) {
	m.cond_test_case_id = &u
}

// CondTestCaseID returns the value of the "cond_test_case_id" field in the mutation.
func (m *CondMutation) CondTestCaseID() (r uuid.UUID, exists bool) {
	v := m.cond_test_case_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCondTestCaseID returns the old "cond_test_case_id" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldCondTestCaseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondTestCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondTestCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondTestCaseID: %w", err)
	}
	return oldValue.CondTestCaseID, nil
}

// ClearCondTestCaseID clears the value of the "cond_test_case_id" field.
func (m *CondMutation) ClearCondTestCaseID() {
	m.cond_test_case_id = nil
	m.clearedFields[cond.FieldCondTestCaseID] = struct{}{}
}

// CondTestCaseIDCleared returns if the "cond_test_case_id" field was cleared in this mutation.
func (m *CondMutation) CondTestCaseIDCleared() bool {
	_, ok := m.clearedFields[cond.FieldCondTestCaseID]
	return ok
}

// ResetCondTestCaseID resets all changes to the "cond_test_case_id" field.
func (m *CondMutation) ResetCondTestCaseID() {
	m.cond_test_case_id = nil
	delete(m.clearedFields, cond.FieldCondTestCaseID)
}

// SetArgumentMap sets the "argument_map" field.
func (m *CondMutation) SetArgumentMap(s string) {
	m.argument_map = &s
}

// ArgumentMap returns the value of the "argument_map" field in the mutation.
func (m *CondMutation) ArgumentMap() (r string, exists bool) {
	v := m.argument_map
	if v == nil {
		return
	}
	return *v, true
}

// OldArgumentMap returns the old "argument_map" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldArgumentMap(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgumentMap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgumentMap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgumentMap: %w", err)
	}
	return oldValue.ArgumentMap, nil
}

// ClearArgumentMap clears the value of the "argument_map" field.
func (m *CondMutation) ClearArgumentMap() {
	m.argument_map = nil
	m.clearedFields[cond.FieldArgumentMap] = struct{}{}
}

// ArgumentMapCleared returns if the "argument_map" field was cleared in this mutation.
func (m *CondMutation) ArgumentMapCleared() bool {
	_, ok := m.clearedFields[cond.FieldArgumentMap]
	return ok
}

// ResetArgumentMap resets all changes to the "argument_map" field.
func (m *CondMutation) ResetArgumentMap() {
	m.argument_map = nil
	delete(m.clearedFields, cond.FieldArgumentMap)
}

// SetIndex sets the "index" field.
func (m *CondMutation) SetIndex(u uint32) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *CondMutation) Index() (r uint32, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *CondMutation) AddIndex(u int32) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *CondMutation) AddedIndex() (r int32, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *CondMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[cond.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *CondMutation) IndexCleared() bool {
	_, ok := m.clearedFields[cond.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *CondMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, cond.FieldIndex)
}

// Where appends a list predicates to the CondMutation builder.
func (m *CondMutation) Where(ps ...predicate.Cond) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CondMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cond).
func (m *CondMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CondMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, cond.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cond.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cond.FieldDeletedAt)
	}
	if m.cond_type != nil {
		fields = append(fields, cond.FieldCondType)
	}
	if m.test_case_id != nil {
		fields = append(fields, cond.FieldTestCaseID)
	}
	if m.cond_test_case_id != nil {
		fields = append(fields, cond.FieldCondTestCaseID)
	}
	if m.argument_map != nil {
		fields = append(fields, cond.FieldArgumentMap)
	}
	if m.index != nil {
		fields = append(fields, cond.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CondMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cond.FieldCreatedAt:
		return m.CreatedAt()
	case cond.FieldUpdatedAt:
		return m.UpdatedAt()
	case cond.FieldDeletedAt:
		return m.DeletedAt()
	case cond.FieldCondType:
		return m.CondType()
	case cond.FieldTestCaseID:
		return m.TestCaseID()
	case cond.FieldCondTestCaseID:
		return m.CondTestCaseID()
	case cond.FieldArgumentMap:
		return m.ArgumentMap()
	case cond.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CondMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cond.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cond.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cond.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cond.FieldCondType:
		return m.OldCondType(ctx)
	case cond.FieldTestCaseID:
		return m.OldTestCaseID(ctx)
	case cond.FieldCondTestCaseID:
		return m.OldCondTestCaseID(ctx)
	case cond.FieldArgumentMap:
		return m.OldArgumentMap(ctx)
	case cond.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown Cond field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CondMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cond.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cond.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cond.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cond.FieldCondType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondType(v)
		return nil
	case cond.FieldTestCaseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseID(v)
		return nil
	case cond.FieldCondTestCaseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondTestCaseID(v)
		return nil
	case cond.FieldArgumentMap:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgumentMap(v)
		return nil
	case cond.FieldIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Cond field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CondMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, cond.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, cond.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, cond.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, cond.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CondMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cond.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cond.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cond.FieldDeletedAt:
		return m.AddedDeletedAt()
	case cond.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CondMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cond.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cond.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cond.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case cond.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Cond numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CondMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cond.FieldCondType) {
		fields = append(fields, cond.FieldCondType)
	}
	if m.FieldCleared(cond.FieldTestCaseID) {
		fields = append(fields, cond.FieldTestCaseID)
	}
	if m.FieldCleared(cond.FieldCondTestCaseID) {
		fields = append(fields, cond.FieldCondTestCaseID)
	}
	if m.FieldCleared(cond.FieldArgumentMap) {
		fields = append(fields, cond.FieldArgumentMap)
	}
	if m.FieldCleared(cond.FieldIndex) {
		fields = append(fields, cond.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CondMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CondMutation) ClearField(name string) error {
	switch name {
	case cond.FieldCondType:
		m.ClearCondType()
		return nil
	case cond.FieldTestCaseID:
		m.ClearTestCaseID()
		return nil
	case cond.FieldCondTestCaseID:
		m.ClearCondTestCaseID()
		return nil
	case cond.FieldArgumentMap:
		m.ClearArgumentMap()
		return nil
	case cond.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown Cond nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CondMutation) ResetField(name string) error {
	switch name {
	case cond.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cond.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cond.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cond.FieldCondType:
		m.ResetCondType()
		return nil
	case cond.FieldTestCaseID:
		m.ResetTestCaseID()
		return nil
	case cond.FieldCondTestCaseID:
		m.ResetCondTestCaseID()
		return nil
	case cond.FieldArgumentMap:
		m.ResetArgumentMap()
		return nil
	case cond.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown Cond field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CondMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CondMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CondMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CondMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CondMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CondMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CondMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cond unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CondMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cond edge %s", name)
}

// ModuleMutation represents an operation that mutates the Module nodes in the graph.
type ModuleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	name          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Module, error)
	predicates    []predicate.Module
}

var _ ent.Mutation = (*ModuleMutation)(nil)

// moduleOption allows management of the mutation configuration using functional options.
type moduleOption func(*ModuleMutation)

// newModuleMutation creates new mutation for the Module entity.
func newModuleMutation(c config, op Op, opts ...moduleOption) *ModuleMutation {
	m := &ModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModuleID sets the ID field of the mutation.
func withModuleID(id uuid.UUID) moduleOption {
	return func(m *ModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Module
		)
		m.oldValue = func(ctx context.Context) (*Module, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Module.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModule sets the old Module of the mutation.
func withModule(node *Module) moduleOption {
	return func(m *ModuleMutation) {
		m.oldValue = func(context.Context) (*Module, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Module entities.
func (m *ModuleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModuleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModuleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Module.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModuleMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModuleMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ModuleMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ModuleMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModuleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModuleMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModuleMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ModuleMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ModuleMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ModuleMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ModuleMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ModuleMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ModuleMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ModuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ModuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ModuleMutation) ClearName() {
	m.name = nil
	m.clearedFields[module.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ModuleMutation) NameCleared() bool {
	_, ok := m.clearedFields[module.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ModuleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, module.FieldName)
}

// SetDescription sets the "description" field.
func (m *ModuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ModuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ModuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[module.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ModuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[module.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ModuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, module.FieldDescription)
}

// Where appends a list predicates to the ModuleMutation builder.
func (m *ModuleMutation) Where(ps ...predicate.Module) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Module).
func (m *ModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModuleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, module.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, module.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, module.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, module.FieldName)
	}
	if m.description != nil {
		fields = append(fields, module.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case module.FieldCreatedAt:
		return m.CreatedAt()
	case module.FieldUpdatedAt:
		return m.UpdatedAt()
	case module.FieldDeletedAt:
		return m.DeletedAt()
	case module.FieldName:
		return m.Name()
	case module.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case module.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case module.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case module.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case module.FieldName:
		return m.OldName(ctx)
	case module.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Module field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case module.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case module.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case module.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case module.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case module.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModuleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, module.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, module.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, module.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case module.FieldCreatedAt:
		return m.AddedCreatedAt()
	case module.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case module.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case module.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case module.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case module.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Module numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(module.FieldName) {
		fields = append(fields, module.FieldName)
	}
	if m.FieldCleared(module.FieldDescription) {
		fields = append(fields, module.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModuleMutation) ClearField(name string) error {
	switch name {
	case module.FieldName:
		m.ClearName()
		return nil
	case module.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Module nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModuleMutation) ResetField(name string) error {
	switch name {
	case module.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case module.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case module.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case module.FieldName:
		m.ResetName()
		return nil
	case module.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Module unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Module edge %s", name)
}

// PlanRelatedTestCaseMutation represents an operation that mutates the PlanRelatedTestCase nodes in the graph.
type PlanRelatedTestCaseMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	test_plan_id     *uuid.UUID
	test_case_id     *uuid.UUID
	test_case_output *string
	description      *string
	test_user_id     *uuid.UUID
	run_duration     *uint32
	addrun_duration  *int32
	result           *string
	index            *uint32
	addindex         *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*PlanRelatedTestCase, error)
	predicates       []predicate.PlanRelatedTestCase
}

var _ ent.Mutation = (*PlanRelatedTestCaseMutation)(nil)

// planrelatedtestcaseOption allows management of the mutation configuration using functional options.
type planrelatedtestcaseOption func(*PlanRelatedTestCaseMutation)

// newPlanRelatedTestCaseMutation creates new mutation for the PlanRelatedTestCase entity.
func newPlanRelatedTestCaseMutation(c config, op Op, opts ...planrelatedtestcaseOption) *PlanRelatedTestCaseMutation {
	m := &PlanRelatedTestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypePlanRelatedTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanRelatedTestCaseID sets the ID field of the mutation.
func withPlanRelatedTestCaseID(id uuid.UUID) planrelatedtestcaseOption {
	return func(m *PlanRelatedTestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanRelatedTestCase
		)
		m.oldValue = func(ctx context.Context) (*PlanRelatedTestCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanRelatedTestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanRelatedTestCase sets the old PlanRelatedTestCase of the mutation.
func withPlanRelatedTestCase(node *PlanRelatedTestCase) planrelatedtestcaseOption {
	return func(m *PlanRelatedTestCaseMutation) {
		m.oldValue = func(context.Context) (*PlanRelatedTestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanRelatedTestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanRelatedTestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanRelatedTestCase entities.
func (m *PlanRelatedTestCaseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanRelatedTestCaseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanRelatedTestCaseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanRelatedTestCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanRelatedTestCaseMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanRelatedTestCaseMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *PlanRelatedTestCaseMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanRelatedTestCaseMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanRelatedTestCaseMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanRelatedTestCaseMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *PlanRelatedTestCaseMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanRelatedTestCaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanRelatedTestCaseMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanRelatedTestCaseMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *PlanRelatedTestCaseMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanRelatedTestCaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTestPlanID sets the "test_plan_id" field.
func (m *PlanRelatedTestCaseMutation) SetTestPlanID(u uuid.UUID) {
	m.test_plan_id = &u
}

// TestPlanID returns the value of the "test_plan_id" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestPlanID() (r uuid.UUID, exists bool) {
	v := m.test_plan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestPlanID returns the old "test_plan_id" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestPlanID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestPlanID: %w", err)
	}
	return oldValue.TestPlanID, nil
}

// ClearTestPlanID clears the value of the "test_plan_id" field.
func (m *PlanRelatedTestCaseMutation) ClearTestPlanID() {
	m.test_plan_id = nil
	m.clearedFields[planrelatedtestcase.FieldTestPlanID] = struct{}{}
}

// TestPlanIDCleared returns if the "test_plan_id" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestPlanIDCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestPlanID]
	return ok
}

// ResetTestPlanID resets all changes to the "test_plan_id" field.
func (m *PlanRelatedTestCaseMutation) ResetTestPlanID() {
	m.test_plan_id = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestPlanID)
}

// SetTestCaseID sets the "test_case_id" field.
func (m *PlanRelatedTestCaseMutation) SetTestCaseID(u uuid.UUID) {
	m.test_case_id = &u
}

// TestCaseID returns the value of the "test_case_id" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseID() (r uuid.UUID, exists bool) {
	v := m.test_case_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseID returns the old "test_case_id" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestCaseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseID: %w", err)
	}
	return oldValue.TestCaseID, nil
}

// ClearTestCaseID clears the value of the "test_case_id" field.
func (m *PlanRelatedTestCaseMutation) ClearTestCaseID() {
	m.test_case_id = nil
	m.clearedFields[planrelatedtestcase.FieldTestCaseID] = struct{}{}
}

// TestCaseIDCleared returns if the "test_case_id" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseIDCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestCaseID]
	return ok
}

// ResetTestCaseID resets all changes to the "test_case_id" field.
func (m *PlanRelatedTestCaseMutation) ResetTestCaseID() {
	m.test_case_id = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestCaseID)
}

// SetTestCaseOutput sets the "test_case_output" field.
func (m *PlanRelatedTestCaseMutation) SetTestCaseOutput(s string) {
	m.test_case_output = &s
}

// TestCaseOutput returns the value of the "test_case_output" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseOutput() (r string, exists bool) {
	v := m.test_case_output
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseOutput returns the old "test_case_output" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestCaseOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseOutput: %w", err)
	}
	return oldValue.TestCaseOutput, nil
}

// ClearTestCaseOutput clears the value of the "test_case_output" field.
func (m *PlanRelatedTestCaseMutation) ClearTestCaseOutput() {
	m.test_case_output = nil
	m.clearedFields[planrelatedtestcase.FieldTestCaseOutput] = struct{}{}
}

// TestCaseOutputCleared returns if the "test_case_output" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseOutputCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestCaseOutput]
	return ok
}

// ResetTestCaseOutput resets all changes to the "test_case_output" field.
func (m *PlanRelatedTestCaseMutation) ResetTestCaseOutput() {
	m.test_case_output = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestCaseOutput)
}

// SetDescription sets the "description" field.
func (m *PlanRelatedTestCaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanRelatedTestCaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanRelatedTestCaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[planrelatedtestcase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanRelatedTestCaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, planrelatedtestcase.FieldDescription)
}

// SetTestUserID sets the "test_user_id" field.
func (m *PlanRelatedTestCaseMutation) SetTestUserID(u uuid.UUID) {
	m.test_user_id = &u
}

// TestUserID returns the value of the "test_user_id" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestUserID() (r uuid.UUID, exists bool) {
	v := m.test_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestUserID returns the old "test_user_id" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestUserID: %w", err)
	}
	return oldValue.TestUserID, nil
}

// ClearTestUserID clears the value of the "test_user_id" field.
func (m *PlanRelatedTestCaseMutation) ClearTestUserID() {
	m.test_user_id = nil
	m.clearedFields[planrelatedtestcase.FieldTestUserID] = struct{}{}
}

// TestUserIDCleared returns if the "test_user_id" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestUserIDCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestUserID]
	return ok
}

// ResetTestUserID resets all changes to the "test_user_id" field.
func (m *PlanRelatedTestCaseMutation) ResetTestUserID() {
	m.test_user_id = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestUserID)
}

// SetRunDuration sets the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) SetRunDuration(u uint32) {
	m.run_duration = &u
	m.addrun_duration = nil
}

// RunDuration returns the value of the "run_duration" field in the mutation.
func (m *PlanRelatedTestCaseMutation) RunDuration() (r uint32, exists bool) {
	v := m.run_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldRunDuration returns the old "run_duration" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldRunDuration(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunDuration: %w", err)
	}
	return oldValue.RunDuration, nil
}

// AddRunDuration adds u to the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) AddRunDuration(u int32) {
	if m.addrun_duration != nil {
		*m.addrun_duration += u
	} else {
		m.addrun_duration = &u
	}
}

// AddedRunDuration returns the value that was added to the "run_duration" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedRunDuration() (r int32, exists bool) {
	v := m.addrun_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearRunDuration clears the value of the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) ClearRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	m.clearedFields[planrelatedtestcase.FieldRunDuration] = struct{}{}
}

// RunDurationCleared returns if the "run_duration" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) RunDurationCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldRunDuration]
	return ok
}

// ResetRunDuration resets all changes to the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) ResetRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	delete(m.clearedFields, planrelatedtestcase.FieldRunDuration)
}

// SetResult sets the "result" field.
func (m *PlanRelatedTestCaseMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *PlanRelatedTestCaseMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *PlanRelatedTestCaseMutation) ClearResult() {
	m.result = nil
	m.clearedFields[planrelatedtestcase.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) ResultCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *PlanRelatedTestCaseMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, planrelatedtestcase.FieldResult)
}

// SetIndex sets the "index" field.
func (m *PlanRelatedTestCaseMutation) SetIndex(u uint32) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *PlanRelatedTestCaseMutation) Index() (r uint32, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *PlanRelatedTestCaseMutation) AddIndex(u int32) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedIndex() (r int32, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *PlanRelatedTestCaseMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[planrelatedtestcase.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) IndexCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *PlanRelatedTestCaseMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, planrelatedtestcase.FieldIndex)
}

// Where appends a list predicates to the PlanRelatedTestCaseMutation builder.
func (m *PlanRelatedTestCaseMutation) Where(ps ...predicate.PlanRelatedTestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlanRelatedTestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PlanRelatedTestCase).
func (m *PlanRelatedTestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanRelatedTestCaseMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, planrelatedtestcase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planrelatedtestcase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, planrelatedtestcase.FieldDeletedAt)
	}
	if m.test_plan_id != nil {
		fields = append(fields, planrelatedtestcase.FieldTestPlanID)
	}
	if m.test_case_id != nil {
		fields = append(fields, planrelatedtestcase.FieldTestCaseID)
	}
	if m.test_case_output != nil {
		fields = append(fields, planrelatedtestcase.FieldTestCaseOutput)
	}
	if m.description != nil {
		fields = append(fields, planrelatedtestcase.FieldDescription)
	}
	if m.test_user_id != nil {
		fields = append(fields, planrelatedtestcase.FieldTestUserID)
	}
	if m.run_duration != nil {
		fields = append(fields, planrelatedtestcase.FieldRunDuration)
	}
	if m.result != nil {
		fields = append(fields, planrelatedtestcase.FieldResult)
	}
	if m.index != nil {
		fields = append(fields, planrelatedtestcase.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanRelatedTestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		return m.CreatedAt()
	case planrelatedtestcase.FieldUpdatedAt:
		return m.UpdatedAt()
	case planrelatedtestcase.FieldDeletedAt:
		return m.DeletedAt()
	case planrelatedtestcase.FieldTestPlanID:
		return m.TestPlanID()
	case planrelatedtestcase.FieldTestCaseID:
		return m.TestCaseID()
	case planrelatedtestcase.FieldTestCaseOutput:
		return m.TestCaseOutput()
	case planrelatedtestcase.FieldDescription:
		return m.Description()
	case planrelatedtestcase.FieldTestUserID:
		return m.TestUserID()
	case planrelatedtestcase.FieldRunDuration:
		return m.RunDuration()
	case planrelatedtestcase.FieldResult:
		return m.Result()
	case planrelatedtestcase.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanRelatedTestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planrelatedtestcase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planrelatedtestcase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case planrelatedtestcase.FieldTestPlanID:
		return m.OldTestPlanID(ctx)
	case planrelatedtestcase.FieldTestCaseID:
		return m.OldTestCaseID(ctx)
	case planrelatedtestcase.FieldTestCaseOutput:
		return m.OldTestCaseOutput(ctx)
	case planrelatedtestcase.FieldDescription:
		return m.OldDescription(ctx)
	case planrelatedtestcase.FieldTestUserID:
		return m.OldTestUserID(ctx)
	case planrelatedtestcase.FieldRunDuration:
		return m.OldRunDuration(ctx)
	case planrelatedtestcase.FieldResult:
		return m.OldResult(ctx)
	case planrelatedtestcase.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown PlanRelatedTestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRelatedTestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planrelatedtestcase.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planrelatedtestcase.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case planrelatedtestcase.FieldTestPlanID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestPlanID(v)
		return nil
	case planrelatedtestcase.FieldTestCaseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseID(v)
		return nil
	case planrelatedtestcase.FieldTestCaseOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseOutput(v)
		return nil
	case planrelatedtestcase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case planrelatedtestcase.FieldTestUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestUserID(v)
		return nil
	case planrelatedtestcase.FieldRunDuration:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunDuration(v)
		return nil
	case planrelatedtestcase.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case planrelatedtestcase.FieldIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanRelatedTestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, planrelatedtestcase.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, planrelatedtestcase.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, planrelatedtestcase.FieldDeletedAt)
	}
	if m.addrun_duration != nil {
		fields = append(fields, planrelatedtestcase.FieldRunDuration)
	}
	if m.addindex != nil {
		fields = append(fields, planrelatedtestcase.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanRelatedTestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		return m.AddedCreatedAt()
	case planrelatedtestcase.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case planrelatedtestcase.FieldDeletedAt:
		return m.AddedDeletedAt()
	case planrelatedtestcase.FieldRunDuration:
		return m.AddedRunDuration()
	case planrelatedtestcase.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRelatedTestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case planrelatedtestcase.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case planrelatedtestcase.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case planrelatedtestcase.FieldRunDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunDuration(v)
		return nil
	case planrelatedtestcase.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanRelatedTestCaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planrelatedtestcase.FieldTestPlanID) {
		fields = append(fields, planrelatedtestcase.FieldTestPlanID)
	}
	if m.FieldCleared(planrelatedtestcase.FieldTestCaseID) {
		fields = append(fields, planrelatedtestcase.FieldTestCaseID)
	}
	if m.FieldCleared(planrelatedtestcase.FieldTestCaseOutput) {
		fields = append(fields, planrelatedtestcase.FieldTestCaseOutput)
	}
	if m.FieldCleared(planrelatedtestcase.FieldDescription) {
		fields = append(fields, planrelatedtestcase.FieldDescription)
	}
	if m.FieldCleared(planrelatedtestcase.FieldTestUserID) {
		fields = append(fields, planrelatedtestcase.FieldTestUserID)
	}
	if m.FieldCleared(planrelatedtestcase.FieldRunDuration) {
		fields = append(fields, planrelatedtestcase.FieldRunDuration)
	}
	if m.FieldCleared(planrelatedtestcase.FieldResult) {
		fields = append(fields, planrelatedtestcase.FieldResult)
	}
	if m.FieldCleared(planrelatedtestcase.FieldIndex) {
		fields = append(fields, planrelatedtestcase.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ClearField(name string) error {
	switch name {
	case planrelatedtestcase.FieldTestPlanID:
		m.ClearTestPlanID()
		return nil
	case planrelatedtestcase.FieldTestCaseID:
		m.ClearTestCaseID()
		return nil
	case planrelatedtestcase.FieldTestCaseOutput:
		m.ClearTestCaseOutput()
		return nil
	case planrelatedtestcase.FieldDescription:
		m.ClearDescription()
		return nil
	case planrelatedtestcase.FieldTestUserID:
		m.ClearTestUserID()
		return nil
	case planrelatedtestcase.FieldRunDuration:
		m.ClearRunDuration()
		return nil
	case planrelatedtestcase.FieldResult:
		m.ClearResult()
		return nil
	case planrelatedtestcase.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ResetField(name string) error {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planrelatedtestcase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planrelatedtestcase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case planrelatedtestcase.FieldTestPlanID:
		m.ResetTestPlanID()
		return nil
	case planrelatedtestcase.FieldTestCaseID:
		m.ResetTestCaseID()
		return nil
	case planrelatedtestcase.FieldTestCaseOutput:
		m.ResetTestCaseOutput()
		return nil
	case planrelatedtestcase.FieldDescription:
		m.ResetDescription()
		return nil
	case planrelatedtestcase.FieldTestUserID:
		m.ResetTestUserID()
		return nil
	case planrelatedtestcase.FieldRunDuration:
		m.ResetRunDuration()
		return nil
	case planrelatedtestcase.FieldResult:
		m.ResetResult()
		return nil
	case planrelatedtestcase.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanRelatedTestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanRelatedTestCaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PlanRelatedTestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PlanRelatedTestCase edge %s", name)
}

// TestCaseMutation represents an operation that mutates the TestCase nodes in the graph.
type TestCaseMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	name           *string
	description    *string
	module_id      *uuid.UUID
	api_id         *uuid.UUID
	input          *string
	input_desc     *string
	expectation    *string
	test_case_type *string
	deprecated     *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*TestCase, error)
	predicates     []predicate.TestCase
}

var _ ent.Mutation = (*TestCaseMutation)(nil)

// testcaseOption allows management of the mutation configuration using functional options.
type testcaseOption func(*TestCaseMutation)

// newTestCaseMutation creates new mutation for the TestCase entity.
func newTestCaseMutation(c config, op Op, opts ...testcaseOption) *TestCaseMutation {
	m := &TestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestCaseID sets the ID field of the mutation.
func withTestCaseID(id uuid.UUID) testcaseOption {
	return func(m *TestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *TestCase
		)
		m.oldValue = func(ctx context.Context) (*TestCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestCase sets the old TestCase of the mutation.
func withTestCase(node *TestCase) testcaseOption {
	return func(m *TestCaseMutation) {
		m.oldValue = func(context.Context) (*TestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestCase entities.
func (m *TestCaseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestCaseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestCaseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TestCaseMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestCaseMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TestCaseMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TestCaseMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestCaseMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestCaseMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestCaseMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TestCaseMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TestCaseMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestCaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TestCaseMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TestCaseMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TestCaseMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TestCaseMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TestCaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *TestCaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestCaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TestCaseMutation) ClearName() {
	m.name = nil
	m.clearedFields[testcase.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TestCaseMutation) NameCleared() bool {
	_, ok := m.clearedFields[testcase.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TestCaseMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, testcase.FieldName)
}

// SetDescription sets the "description" field.
func (m *TestCaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TestCaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TestCaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[testcase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TestCaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[testcase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TestCaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, testcase.FieldDescription)
}

// SetModuleID sets the "module_id" field.
func (m *TestCaseMutation) SetModuleID(u uuid.UUID) {
	m.module_id = &u
}

// ModuleID returns the value of the "module_id" field in the mutation.
func (m *TestCaseMutation) ModuleID() (r uuid.UUID, exists bool) {
	v := m.module_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleID returns the old "module_id" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldModuleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleID: %w", err)
	}
	return oldValue.ModuleID, nil
}

// ClearModuleID clears the value of the "module_id" field.
func (m *TestCaseMutation) ClearModuleID() {
	m.module_id = nil
	m.clearedFields[testcase.FieldModuleID] = struct{}{}
}

// ModuleIDCleared returns if the "module_id" field was cleared in this mutation.
func (m *TestCaseMutation) ModuleIDCleared() bool {
	_, ok := m.clearedFields[testcase.FieldModuleID]
	return ok
}

// ResetModuleID resets all changes to the "module_id" field.
func (m *TestCaseMutation) ResetModuleID() {
	m.module_id = nil
	delete(m.clearedFields, testcase.FieldModuleID)
}

// SetAPIID sets the "api_id" field.
func (m *TestCaseMutation) SetAPIID(u uuid.UUID) {
	m.api_id = &u
}

// APIID returns the value of the "api_id" field in the mutation.
func (m *TestCaseMutation) APIID() (r uuid.UUID, exists bool) {
	v := m.api_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIID returns the old "api_id" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldAPIID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIID: %w", err)
	}
	return oldValue.APIID, nil
}

// ClearAPIID clears the value of the "api_id" field.
func (m *TestCaseMutation) ClearAPIID() {
	m.api_id = nil
	m.clearedFields[testcase.FieldAPIID] = struct{}{}
}

// APIIDCleared returns if the "api_id" field was cleared in this mutation.
func (m *TestCaseMutation) APIIDCleared() bool {
	_, ok := m.clearedFields[testcase.FieldAPIID]
	return ok
}

// ResetAPIID resets all changes to the "api_id" field.
func (m *TestCaseMutation) ResetAPIID() {
	m.api_id = nil
	delete(m.clearedFields, testcase.FieldAPIID)
}

// SetInput sets the "input" field.
func (m *TestCaseMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *TestCaseMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ClearInput clears the value of the "input" field.
func (m *TestCaseMutation) ClearInput() {
	m.input = nil
	m.clearedFields[testcase.FieldInput] = struct{}{}
}

// InputCleared returns if the "input" field was cleared in this mutation.
func (m *TestCaseMutation) InputCleared() bool {
	_, ok := m.clearedFields[testcase.FieldInput]
	return ok
}

// ResetInput resets all changes to the "input" field.
func (m *TestCaseMutation) ResetInput() {
	m.input = nil
	delete(m.clearedFields, testcase.FieldInput)
}

// SetInputDesc sets the "input_desc" field.
func (m *TestCaseMutation) SetInputDesc(s string) {
	m.input_desc = &s
}

// InputDesc returns the value of the "input_desc" field in the mutation.
func (m *TestCaseMutation) InputDesc() (r string, exists bool) {
	v := m.input_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldInputDesc returns the old "input_desc" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldInputDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputDesc: %w", err)
	}
	return oldValue.InputDesc, nil
}

// ClearInputDesc clears the value of the "input_desc" field.
func (m *TestCaseMutation) ClearInputDesc() {
	m.input_desc = nil
	m.clearedFields[testcase.FieldInputDesc] = struct{}{}
}

// InputDescCleared returns if the "input_desc" field was cleared in this mutation.
func (m *TestCaseMutation) InputDescCleared() bool {
	_, ok := m.clearedFields[testcase.FieldInputDesc]
	return ok
}

// ResetInputDesc resets all changes to the "input_desc" field.
func (m *TestCaseMutation) ResetInputDesc() {
	m.input_desc = nil
	delete(m.clearedFields, testcase.FieldInputDesc)
}

// SetExpectation sets the "expectation" field.
func (m *TestCaseMutation) SetExpectation(s string) {
	m.expectation = &s
}

// Expectation returns the value of the "expectation" field in the mutation.
func (m *TestCaseMutation) Expectation() (r string, exists bool) {
	v := m.expectation
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectation returns the old "expectation" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldExpectation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectation: %w", err)
	}
	return oldValue.Expectation, nil
}

// ClearExpectation clears the value of the "expectation" field.
func (m *TestCaseMutation) ClearExpectation() {
	m.expectation = nil
	m.clearedFields[testcase.FieldExpectation] = struct{}{}
}

// ExpectationCleared returns if the "expectation" field was cleared in this mutation.
func (m *TestCaseMutation) ExpectationCleared() bool {
	_, ok := m.clearedFields[testcase.FieldExpectation]
	return ok
}

// ResetExpectation resets all changes to the "expectation" field.
func (m *TestCaseMutation) ResetExpectation() {
	m.expectation = nil
	delete(m.clearedFields, testcase.FieldExpectation)
}

// SetTestCaseType sets the "test_case_type" field.
func (m *TestCaseMutation) SetTestCaseType(s string) {
	m.test_case_type = &s
}

// TestCaseType returns the value of the "test_case_type" field in the mutation.
func (m *TestCaseMutation) TestCaseType() (r string, exists bool) {
	v := m.test_case_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseType returns the old "test_case_type" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldTestCaseType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseType: %w", err)
	}
	return oldValue.TestCaseType, nil
}

// ClearTestCaseType clears the value of the "test_case_type" field.
func (m *TestCaseMutation) ClearTestCaseType() {
	m.test_case_type = nil
	m.clearedFields[testcase.FieldTestCaseType] = struct{}{}
}

// TestCaseTypeCleared returns if the "test_case_type" field was cleared in this mutation.
func (m *TestCaseMutation) TestCaseTypeCleared() bool {
	_, ok := m.clearedFields[testcase.FieldTestCaseType]
	return ok
}

// ResetTestCaseType resets all changes to the "test_case_type" field.
func (m *TestCaseMutation) ResetTestCaseType() {
	m.test_case_type = nil
	delete(m.clearedFields, testcase.FieldTestCaseType)
}

// SetDeprecated sets the "deprecated" field.
func (m *TestCaseMutation) SetDeprecated(b bool) {
	m.deprecated = &b
}

// Deprecated returns the value of the "deprecated" field in the mutation.
func (m *TestCaseMutation) Deprecated() (r bool, exists bool) {
	v := m.deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldDeprecated returns the old "deprecated" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeprecated: %w", err)
	}
	return oldValue.Deprecated, nil
}

// ClearDeprecated clears the value of the "deprecated" field.
func (m *TestCaseMutation) ClearDeprecated() {
	m.deprecated = nil
	m.clearedFields[testcase.FieldDeprecated] = struct{}{}
}

// DeprecatedCleared returns if the "deprecated" field was cleared in this mutation.
func (m *TestCaseMutation) DeprecatedCleared() bool {
	_, ok := m.clearedFields[testcase.FieldDeprecated]
	return ok
}

// ResetDeprecated resets all changes to the "deprecated" field.
func (m *TestCaseMutation) ResetDeprecated() {
	m.deprecated = nil
	delete(m.clearedFields, testcase.FieldDeprecated)
}

// Where appends a list predicates to the TestCaseMutation builder.
func (m *TestCaseMutation) Where(ps ...predicate.TestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestCase).
func (m *TestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestCaseMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, testcase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testcase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, testcase.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, testcase.FieldName)
	}
	if m.description != nil {
		fields = append(fields, testcase.FieldDescription)
	}
	if m.module_id != nil {
		fields = append(fields, testcase.FieldModuleID)
	}
	if m.api_id != nil {
		fields = append(fields, testcase.FieldAPIID)
	}
	if m.input != nil {
		fields = append(fields, testcase.FieldInput)
	}
	if m.input_desc != nil {
		fields = append(fields, testcase.FieldInputDesc)
	}
	if m.expectation != nil {
		fields = append(fields, testcase.FieldExpectation)
	}
	if m.test_case_type != nil {
		fields = append(fields, testcase.FieldTestCaseType)
	}
	if m.deprecated != nil {
		fields = append(fields, testcase.FieldDeprecated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldCreatedAt:
		return m.CreatedAt()
	case testcase.FieldUpdatedAt:
		return m.UpdatedAt()
	case testcase.FieldDeletedAt:
		return m.DeletedAt()
	case testcase.FieldName:
		return m.Name()
	case testcase.FieldDescription:
		return m.Description()
	case testcase.FieldModuleID:
		return m.ModuleID()
	case testcase.FieldAPIID:
		return m.APIID()
	case testcase.FieldInput:
		return m.Input()
	case testcase.FieldInputDesc:
		return m.InputDesc()
	case testcase.FieldExpectation:
		return m.Expectation()
	case testcase.FieldTestCaseType:
		return m.TestCaseType()
	case testcase.FieldDeprecated:
		return m.Deprecated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testcase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testcase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case testcase.FieldName:
		return m.OldName(ctx)
	case testcase.FieldDescription:
		return m.OldDescription(ctx)
	case testcase.FieldModuleID:
		return m.OldModuleID(ctx)
	case testcase.FieldAPIID:
		return m.OldAPIID(ctx)
	case testcase.FieldInput:
		return m.OldInput(ctx)
	case testcase.FieldInputDesc:
		return m.OldInputDesc(ctx)
	case testcase.FieldExpectation:
		return m.OldExpectation(ctx)
	case testcase.FieldTestCaseType:
		return m.OldTestCaseType(ctx)
	case testcase.FieldDeprecated:
		return m.OldDeprecated(ctx)
	}
	return nil, fmt.Errorf("unknown TestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testcase.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testcase.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case testcase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testcase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case testcase.FieldModuleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleID(v)
		return nil
	case testcase.FieldAPIID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIID(v)
		return nil
	case testcase.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case testcase.FieldInputDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputDesc(v)
		return nil
	case testcase.FieldExpectation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectation(v)
		return nil
	case testcase.FieldTestCaseType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseType(v)
		return nil
	case testcase.FieldDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeprecated(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, testcase.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, testcase.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, testcase.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldCreatedAt:
		return m.AddedCreatedAt()
	case testcase.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case testcase.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case testcase.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case testcase.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestCaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testcase.FieldName) {
		fields = append(fields, testcase.FieldName)
	}
	if m.FieldCleared(testcase.FieldDescription) {
		fields = append(fields, testcase.FieldDescription)
	}
	if m.FieldCleared(testcase.FieldModuleID) {
		fields = append(fields, testcase.FieldModuleID)
	}
	if m.FieldCleared(testcase.FieldAPIID) {
		fields = append(fields, testcase.FieldAPIID)
	}
	if m.FieldCleared(testcase.FieldInput) {
		fields = append(fields, testcase.FieldInput)
	}
	if m.FieldCleared(testcase.FieldInputDesc) {
		fields = append(fields, testcase.FieldInputDesc)
	}
	if m.FieldCleared(testcase.FieldExpectation) {
		fields = append(fields, testcase.FieldExpectation)
	}
	if m.FieldCleared(testcase.FieldTestCaseType) {
		fields = append(fields, testcase.FieldTestCaseType)
	}
	if m.FieldCleared(testcase.FieldDeprecated) {
		fields = append(fields, testcase.FieldDeprecated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestCaseMutation) ClearField(name string) error {
	switch name {
	case testcase.FieldName:
		m.ClearName()
		return nil
	case testcase.FieldDescription:
		m.ClearDescription()
		return nil
	case testcase.FieldModuleID:
		m.ClearModuleID()
		return nil
	case testcase.FieldAPIID:
		m.ClearAPIID()
		return nil
	case testcase.FieldInput:
		m.ClearInput()
		return nil
	case testcase.FieldInputDesc:
		m.ClearInputDesc()
		return nil
	case testcase.FieldExpectation:
		m.ClearExpectation()
		return nil
	case testcase.FieldTestCaseType:
		m.ClearTestCaseType()
		return nil
	case testcase.FieldDeprecated:
		m.ClearDeprecated()
		return nil
	}
	return fmt.Errorf("unknown TestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestCaseMutation) ResetField(name string) error {
	switch name {
	case testcase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testcase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testcase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case testcase.FieldName:
		m.ResetName()
		return nil
	case testcase.FieldDescription:
		m.ResetDescription()
		return nil
	case testcase.FieldModuleID:
		m.ResetModuleID()
		return nil
	case testcase.FieldAPIID:
		m.ResetAPIID()
		return nil
	case testcase.FieldInput:
		m.ResetInput()
		return nil
	case testcase.FieldInputDesc:
		m.ResetInputDesc()
		return nil
	case testcase.FieldExpectation:
		m.ResetExpectation()
		return nil
	case testcase.FieldTestCaseType:
		m.ResetTestCaseType()
		return nil
	case testcase.FieldDeprecated:
		m.ResetDeprecated()
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestCaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestCaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestCaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestCaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestCaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestCase edge %s", name)
}

// TestPlanMutation represents an operation that mutates the TestPlan nodes in the graph.
type TestPlanMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	name            *string
	state           *string
	created_by      *uuid.UUID
	executor        *uuid.UUID
	fails           *uint32
	addfails        *int32
	passes          *uint32
	addpasses       *int32
	skips           *uint32
	addskips        *int32
	run_duration    *uint32
	addrun_duration *int32
	deadline        *uint32
	adddeadline     *int32
	result          *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TestPlan, error)
	predicates      []predicate.TestPlan
}

var _ ent.Mutation = (*TestPlanMutation)(nil)

// testplanOption allows management of the mutation configuration using functional options.
type testplanOption func(*TestPlanMutation)

// newTestPlanMutation creates new mutation for the TestPlan entity.
func newTestPlanMutation(c config, op Op, opts ...testplanOption) *TestPlanMutation {
	m := &TestPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeTestPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestPlanID sets the ID field of the mutation.
func withTestPlanID(id uuid.UUID) testplanOption {
	return func(m *TestPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *TestPlan
		)
		m.oldValue = func(ctx context.Context) (*TestPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestPlan sets the old TestPlan of the mutation.
func withTestPlan(node *TestPlan) testplanOption {
	return func(m *TestPlanMutation) {
		m.oldValue = func(context.Context) (*TestPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestPlan entities.
func (m *TestPlanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestPlanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestPlanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TestPlanMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestPlanMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TestPlanMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TestPlanMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestPlanMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestPlanMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestPlanMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TestPlanMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TestPlanMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TestPlanMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TestPlanMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TestPlanMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TestPlanMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TestPlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *TestPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TestPlanMutation) ClearName() {
	m.name = nil
	m.clearedFields[testplan.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TestPlanMutation) NameCleared() bool {
	_, ok := m.clearedFields[testplan.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TestPlanMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, testplan.FieldName)
}

// SetState sets the "state" field.
func (m *TestPlanMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *TestPlanMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *TestPlanMutation) ClearState() {
	m.state = nil
	m.clearedFields[testplan.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *TestPlanMutation) StateCleared() bool {
	_, ok := m.clearedFields[testplan.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *TestPlanMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, testplan.FieldState)
}

// SetCreatedBy sets the "created_by" field.
func (m *TestPlanMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TestPlanMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TestPlanMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[testplan.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TestPlanMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[testplan.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TestPlanMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, testplan.FieldCreatedBy)
}

// SetExecutor sets the "executor" field.
func (m *TestPlanMutation) SetExecutor(u uuid.UUID) {
	m.executor = &u
}

// Executor returns the value of the "executor" field in the mutation.
func (m *TestPlanMutation) Executor() (r uuid.UUID, exists bool) {
	v := m.executor
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutor returns the old "executor" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldExecutor(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutor: %w", err)
	}
	return oldValue.Executor, nil
}

// ClearExecutor clears the value of the "executor" field.
func (m *TestPlanMutation) ClearExecutor() {
	m.executor = nil
	m.clearedFields[testplan.FieldExecutor] = struct{}{}
}

// ExecutorCleared returns if the "executor" field was cleared in this mutation.
func (m *TestPlanMutation) ExecutorCleared() bool {
	_, ok := m.clearedFields[testplan.FieldExecutor]
	return ok
}

// ResetExecutor resets all changes to the "executor" field.
func (m *TestPlanMutation) ResetExecutor() {
	m.executor = nil
	delete(m.clearedFields, testplan.FieldExecutor)
}

// SetFails sets the "fails" field.
func (m *TestPlanMutation) SetFails(u uint32) {
	m.fails = &u
	m.addfails = nil
}

// Fails returns the value of the "fails" field in the mutation.
func (m *TestPlanMutation) Fails() (r uint32, exists bool) {
	v := m.fails
	if v == nil {
		return
	}
	return *v, true
}

// OldFails returns the old "fails" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldFails(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFails: %w", err)
	}
	return oldValue.Fails, nil
}

// AddFails adds u to the "fails" field.
func (m *TestPlanMutation) AddFails(u int32) {
	if m.addfails != nil {
		*m.addfails += u
	} else {
		m.addfails = &u
	}
}

// AddedFails returns the value that was added to the "fails" field in this mutation.
func (m *TestPlanMutation) AddedFails() (r int32, exists bool) {
	v := m.addfails
	if v == nil {
		return
	}
	return *v, true
}

// ClearFails clears the value of the "fails" field.
func (m *TestPlanMutation) ClearFails() {
	m.fails = nil
	m.addfails = nil
	m.clearedFields[testplan.FieldFails] = struct{}{}
}

// FailsCleared returns if the "fails" field was cleared in this mutation.
func (m *TestPlanMutation) FailsCleared() bool {
	_, ok := m.clearedFields[testplan.FieldFails]
	return ok
}

// ResetFails resets all changes to the "fails" field.
func (m *TestPlanMutation) ResetFails() {
	m.fails = nil
	m.addfails = nil
	delete(m.clearedFields, testplan.FieldFails)
}

// SetPasses sets the "passes" field.
func (m *TestPlanMutation) SetPasses(u uint32) {
	m.passes = &u
	m.addpasses = nil
}

// Passes returns the value of the "passes" field in the mutation.
func (m *TestPlanMutation) Passes() (r uint32, exists bool) {
	v := m.passes
	if v == nil {
		return
	}
	return *v, true
}

// OldPasses returns the old "passes" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldPasses(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasses: %w", err)
	}
	return oldValue.Passes, nil
}

// AddPasses adds u to the "passes" field.
func (m *TestPlanMutation) AddPasses(u int32) {
	if m.addpasses != nil {
		*m.addpasses += u
	} else {
		m.addpasses = &u
	}
}

// AddedPasses returns the value that was added to the "passes" field in this mutation.
func (m *TestPlanMutation) AddedPasses() (r int32, exists bool) {
	v := m.addpasses
	if v == nil {
		return
	}
	return *v, true
}

// ClearPasses clears the value of the "passes" field.
func (m *TestPlanMutation) ClearPasses() {
	m.passes = nil
	m.addpasses = nil
	m.clearedFields[testplan.FieldPasses] = struct{}{}
}

// PassesCleared returns if the "passes" field was cleared in this mutation.
func (m *TestPlanMutation) PassesCleared() bool {
	_, ok := m.clearedFields[testplan.FieldPasses]
	return ok
}

// ResetPasses resets all changes to the "passes" field.
func (m *TestPlanMutation) ResetPasses() {
	m.passes = nil
	m.addpasses = nil
	delete(m.clearedFields, testplan.FieldPasses)
}

// SetSkips sets the "skips" field.
func (m *TestPlanMutation) SetSkips(u uint32) {
	m.skips = &u
	m.addskips = nil
}

// Skips returns the value of the "skips" field in the mutation.
func (m *TestPlanMutation) Skips() (r uint32, exists bool) {
	v := m.skips
	if v == nil {
		return
	}
	return *v, true
}

// OldSkips returns the old "skips" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldSkips(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkips is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkips requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkips: %w", err)
	}
	return oldValue.Skips, nil
}

// AddSkips adds u to the "skips" field.
func (m *TestPlanMutation) AddSkips(u int32) {
	if m.addskips != nil {
		*m.addskips += u
	} else {
		m.addskips = &u
	}
}

// AddedSkips returns the value that was added to the "skips" field in this mutation.
func (m *TestPlanMutation) AddedSkips() (r int32, exists bool) {
	v := m.addskips
	if v == nil {
		return
	}
	return *v, true
}

// ClearSkips clears the value of the "skips" field.
func (m *TestPlanMutation) ClearSkips() {
	m.skips = nil
	m.addskips = nil
	m.clearedFields[testplan.FieldSkips] = struct{}{}
}

// SkipsCleared returns if the "skips" field was cleared in this mutation.
func (m *TestPlanMutation) SkipsCleared() bool {
	_, ok := m.clearedFields[testplan.FieldSkips]
	return ok
}

// ResetSkips resets all changes to the "skips" field.
func (m *TestPlanMutation) ResetSkips() {
	m.skips = nil
	m.addskips = nil
	delete(m.clearedFields, testplan.FieldSkips)
}

// SetRunDuration sets the "run_duration" field.
func (m *TestPlanMutation) SetRunDuration(u uint32) {
	m.run_duration = &u
	m.addrun_duration = nil
}

// RunDuration returns the value of the "run_duration" field in the mutation.
func (m *TestPlanMutation) RunDuration() (r uint32, exists bool) {
	v := m.run_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldRunDuration returns the old "run_duration" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldRunDuration(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunDuration: %w", err)
	}
	return oldValue.RunDuration, nil
}

// AddRunDuration adds u to the "run_duration" field.
func (m *TestPlanMutation) AddRunDuration(u int32) {
	if m.addrun_duration != nil {
		*m.addrun_duration += u
	} else {
		m.addrun_duration = &u
	}
}

// AddedRunDuration returns the value that was added to the "run_duration" field in this mutation.
func (m *TestPlanMutation) AddedRunDuration() (r int32, exists bool) {
	v := m.addrun_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearRunDuration clears the value of the "run_duration" field.
func (m *TestPlanMutation) ClearRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	m.clearedFields[testplan.FieldRunDuration] = struct{}{}
}

// RunDurationCleared returns if the "run_duration" field was cleared in this mutation.
func (m *TestPlanMutation) RunDurationCleared() bool {
	_, ok := m.clearedFields[testplan.FieldRunDuration]
	return ok
}

// ResetRunDuration resets all changes to the "run_duration" field.
func (m *TestPlanMutation) ResetRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	delete(m.clearedFields, testplan.FieldRunDuration)
}

// SetDeadline sets the "deadline" field.
func (m *TestPlanMutation) SetDeadline(u uint32) {
	m.deadline = &u
	m.adddeadline = nil
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *TestPlanMutation) Deadline() (r uint32, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldDeadline(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// AddDeadline adds u to the "deadline" field.
func (m *TestPlanMutation) AddDeadline(u int32) {
	if m.adddeadline != nil {
		*m.adddeadline += u
	} else {
		m.adddeadline = &u
	}
}

// AddedDeadline returns the value that was added to the "deadline" field in this mutation.
func (m *TestPlanMutation) AddedDeadline() (r int32, exists bool) {
	v := m.adddeadline
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeadline clears the value of the "deadline" field.
func (m *TestPlanMutation) ClearDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	m.clearedFields[testplan.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *TestPlanMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[testplan.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *TestPlanMutation) ResetDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	delete(m.clearedFields, testplan.FieldDeadline)
}

// SetResult sets the "result" field.
func (m *TestPlanMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *TestPlanMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *TestPlanMutation) ClearResult() {
	m.result = nil
	m.clearedFields[testplan.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *TestPlanMutation) ResultCleared() bool {
	_, ok := m.clearedFields[testplan.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *TestPlanMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, testplan.FieldResult)
}

// Where appends a list predicates to the TestPlanMutation builder.
func (m *TestPlanMutation) Where(ps ...predicate.TestPlan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestPlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestPlan).
func (m *TestPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestPlanMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, testplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testplan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, testplan.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, testplan.FieldName)
	}
	if m.state != nil {
		fields = append(fields, testplan.FieldState)
	}
	if m.created_by != nil {
		fields = append(fields, testplan.FieldCreatedBy)
	}
	if m.executor != nil {
		fields = append(fields, testplan.FieldExecutor)
	}
	if m.fails != nil {
		fields = append(fields, testplan.FieldFails)
	}
	if m.passes != nil {
		fields = append(fields, testplan.FieldPasses)
	}
	if m.skips != nil {
		fields = append(fields, testplan.FieldSkips)
	}
	if m.run_duration != nil {
		fields = append(fields, testplan.FieldRunDuration)
	}
	if m.deadline != nil {
		fields = append(fields, testplan.FieldDeadline)
	}
	if m.result != nil {
		fields = append(fields, testplan.FieldResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testplan.FieldCreatedAt:
		return m.CreatedAt()
	case testplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case testplan.FieldDeletedAt:
		return m.DeletedAt()
	case testplan.FieldName:
		return m.Name()
	case testplan.FieldState:
		return m.State()
	case testplan.FieldCreatedBy:
		return m.CreatedBy()
	case testplan.FieldExecutor:
		return m.Executor()
	case testplan.FieldFails:
		return m.Fails()
	case testplan.FieldPasses:
		return m.Passes()
	case testplan.FieldSkips:
		return m.Skips()
	case testplan.FieldRunDuration:
		return m.RunDuration()
	case testplan.FieldDeadline:
		return m.Deadline()
	case testplan.FieldResult:
		return m.Result()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testplan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case testplan.FieldName:
		return m.OldName(ctx)
	case testplan.FieldState:
		return m.OldState(ctx)
	case testplan.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case testplan.FieldExecutor:
		return m.OldExecutor(ctx)
	case testplan.FieldFails:
		return m.OldFails(ctx)
	case testplan.FieldPasses:
		return m.OldPasses(ctx)
	case testplan.FieldSkips:
		return m.OldSkips(ctx)
	case testplan.FieldRunDuration:
		return m.OldRunDuration(ctx)
	case testplan.FieldDeadline:
		return m.OldDeadline(ctx)
	case testplan.FieldResult:
		return m.OldResult(ctx)
	}
	return nil, fmt.Errorf("unknown TestPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testplan.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testplan.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testplan.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case testplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testplan.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case testplan.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case testplan.FieldExecutor:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutor(v)
		return nil
	case testplan.FieldFails:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFails(v)
		return nil
	case testplan.FieldPasses:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasses(v)
		return nil
	case testplan.FieldSkips:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkips(v)
		return nil
	case testplan.FieldRunDuration:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunDuration(v)
		return nil
	case testplan.FieldDeadline:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case testplan.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	}
	return fmt.Errorf("unknown TestPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestPlanMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, testplan.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, testplan.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, testplan.FieldDeletedAt)
	}
	if m.addfails != nil {
		fields = append(fields, testplan.FieldFails)
	}
	if m.addpasses != nil {
		fields = append(fields, testplan.FieldPasses)
	}
	if m.addskips != nil {
		fields = append(fields, testplan.FieldSkips)
	}
	if m.addrun_duration != nil {
		fields = append(fields, testplan.FieldRunDuration)
	}
	if m.adddeadline != nil {
		fields = append(fields, testplan.FieldDeadline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testplan.FieldCreatedAt:
		return m.AddedCreatedAt()
	case testplan.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case testplan.FieldDeletedAt:
		return m.AddedDeletedAt()
	case testplan.FieldFails:
		return m.AddedFails()
	case testplan.FieldPasses:
		return m.AddedPasses()
	case testplan.FieldSkips:
		return m.AddedSkips()
	case testplan.FieldRunDuration:
		return m.AddedRunDuration()
	case testplan.FieldDeadline:
		return m.AddedDeadline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testplan.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case testplan.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case testplan.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case testplan.FieldFails:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFails(v)
		return nil
	case testplan.FieldPasses:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPasses(v)
		return nil
	case testplan.FieldSkips:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkips(v)
		return nil
	case testplan.FieldRunDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunDuration(v)
		return nil
	case testplan.FieldDeadline:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadline(v)
		return nil
	}
	return fmt.Errorf("unknown TestPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testplan.FieldName) {
		fields = append(fields, testplan.FieldName)
	}
	if m.FieldCleared(testplan.FieldState) {
		fields = append(fields, testplan.FieldState)
	}
	if m.FieldCleared(testplan.FieldCreatedBy) {
		fields = append(fields, testplan.FieldCreatedBy)
	}
	if m.FieldCleared(testplan.FieldExecutor) {
		fields = append(fields, testplan.FieldExecutor)
	}
	if m.FieldCleared(testplan.FieldFails) {
		fields = append(fields, testplan.FieldFails)
	}
	if m.FieldCleared(testplan.FieldPasses) {
		fields = append(fields, testplan.FieldPasses)
	}
	if m.FieldCleared(testplan.FieldSkips) {
		fields = append(fields, testplan.FieldSkips)
	}
	if m.FieldCleared(testplan.FieldRunDuration) {
		fields = append(fields, testplan.FieldRunDuration)
	}
	if m.FieldCleared(testplan.FieldDeadline) {
		fields = append(fields, testplan.FieldDeadline)
	}
	if m.FieldCleared(testplan.FieldResult) {
		fields = append(fields, testplan.FieldResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestPlanMutation) ClearField(name string) error {
	switch name {
	case testplan.FieldName:
		m.ClearName()
		return nil
	case testplan.FieldState:
		m.ClearState()
		return nil
	case testplan.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case testplan.FieldExecutor:
		m.ClearExecutor()
		return nil
	case testplan.FieldFails:
		m.ClearFails()
		return nil
	case testplan.FieldPasses:
		m.ClearPasses()
		return nil
	case testplan.FieldSkips:
		m.ClearSkips()
		return nil
	case testplan.FieldRunDuration:
		m.ClearRunDuration()
		return nil
	case testplan.FieldDeadline:
		m.ClearDeadline()
		return nil
	case testplan.FieldResult:
		m.ClearResult()
		return nil
	}
	return fmt.Errorf("unknown TestPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestPlanMutation) ResetField(name string) error {
	switch name {
	case testplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testplan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case testplan.FieldName:
		m.ResetName()
		return nil
	case testplan.FieldState:
		m.ResetState()
		return nil
	case testplan.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case testplan.FieldExecutor:
		m.ResetExecutor()
		return nil
	case testplan.FieldFails:
		m.ResetFails()
		return nil
	case testplan.FieldPasses:
		m.ResetPasses()
		return nil
	case testplan.FieldSkips:
		m.ResetSkips()
		return nil
	case testplan.FieldRunDuration:
		m.ResetRunDuration()
		return nil
	case testplan.FieldDeadline:
		m.ResetDeadline()
		return nil
	case testplan.FieldResult:
		m.ResetResult()
		return nil
	}
	return fmt.Errorf("unknown TestPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestPlanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestPlanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestPlanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestPlanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestPlanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestPlan edge %s", name)
}
