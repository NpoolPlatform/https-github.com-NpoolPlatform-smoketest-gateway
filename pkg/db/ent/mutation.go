// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/cond"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/module"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/planrelatedtestcase"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/testcase"
	"github.com/NpoolPlatform/smoketest-middleware/pkg/db/ent/testplan"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCond                = "Cond"
	TypeModule              = "Module"
	TypePlanRelatedTestCase = "PlanRelatedTestCase"
	TypeTestCase            = "TestCase"
	TypeTestPlan            = "TestPlan"
)

// CondMutation represents an operation that mutates the Cond nodes in the graph.
type CondMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	cond_type         *string
	test_case_id      *uuid.UUID
	cond_test_case_id *uuid.UUID
	argument_map      *string
	index             *uint32
	addindex          *int32
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Cond, error)
	predicates        []predicate.Cond
}

var _ ent.Mutation = (*CondMutation)(nil)

// condOption allows management of the mutation configuration using functional options.
type condOption func(*CondMutation)

// newCondMutation creates new mutation for the Cond entity.
func newCondMutation(c config, op Op, opts ...condOption) *CondMutation {
	m := &CondMutation{
		config:        c,
		op:            op,
		typ:           TypeCond,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCondID sets the ID field of the mutation.
func withCondID(id uuid.UUID) condOption {
	return func(m *CondMutation) {
		var (
			err   error
			once  sync.Once
			value *Cond
		)
		m.oldValue = func(ctx context.Context) (*Cond, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cond.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCond sets the old Cond of the mutation.
func withCond(node *Cond) condOption {
	return func(m *CondMutation) {
		m.oldValue = func(context.Context) (*Cond, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CondMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CondMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cond entities.
func (m *CondMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CondMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CondMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cond.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CondMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CondMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CondMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CondMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CondMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CondMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CondMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CondMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CondMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CondMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CondMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CondMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CondMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CondMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CondMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCondType sets the "cond_type" field.
func (m *CondMutation) SetCondType(s string) {
	m.cond_type = &s
}

// CondType returns the value of the "cond_type" field in the mutation.
func (m *CondMutation) CondType() (r string, exists bool) {
	v := m.cond_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCondType returns the old "cond_type" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldCondType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondType: %w", err)
	}
	return oldValue.CondType, nil
}

// ClearCondType clears the value of the "cond_type" field.
func (m *CondMutation) ClearCondType() {
	m.cond_type = nil
	m.clearedFields[cond.FieldCondType] = struct{}{}
}

// CondTypeCleared returns if the "cond_type" field was cleared in this mutation.
func (m *CondMutation) CondTypeCleared() bool {
	_, ok := m.clearedFields[cond.FieldCondType]
	return ok
}

// ResetCondType resets all changes to the "cond_type" field.
func (m *CondMutation) ResetCondType() {
	m.cond_type = nil
	delete(m.clearedFields, cond.FieldCondType)
}

// SetTestCaseID sets the "test_case_id" field.
func (m *CondMutation) SetTestCaseID(u uuid.UUID) {
	m.test_case_id = &u
}

// TestCaseID returns the value of the "test_case_id" field in the mutation.
func (m *CondMutation) TestCaseID() (r uuid.UUID, exists bool) {
	v := m.test_case_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseID returns the old "test_case_id" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldTestCaseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseID: %w", err)
	}
	return oldValue.TestCaseID, nil
}

// ClearTestCaseID clears the value of the "test_case_id" field.
func (m *CondMutation) ClearTestCaseID() {
	m.test_case_id = nil
	m.clearedFields[cond.FieldTestCaseID] = struct{}{}
}

// TestCaseIDCleared returns if the "test_case_id" field was cleared in this mutation.
func (m *CondMutation) TestCaseIDCleared() bool {
	_, ok := m.clearedFields[cond.FieldTestCaseID]
	return ok
}

// ResetTestCaseID resets all changes to the "test_case_id" field.
func (m *CondMutation) ResetTestCaseID() {
	m.test_case_id = nil
	delete(m.clearedFields, cond.FieldTestCaseID)
}

// SetCondTestCaseID sets the "cond_test_case_id" field.
func (m *CondMutation) SetCondTestCaseID(u uuid.UUID) {
	m.cond_test_case_id = &u
}

// CondTestCaseID returns the value of the "cond_test_case_id" field in the mutation.
func (m *CondMutation) CondTestCaseID() (r uuid.UUID, exists bool) {
	v := m.cond_test_case_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCondTestCaseID returns the old "cond_test_case_id" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldCondTestCaseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondTestCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondTestCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondTestCaseID: %w", err)
	}
	return oldValue.CondTestCaseID, nil
}

// ClearCondTestCaseID clears the value of the "cond_test_case_id" field.
func (m *CondMutation) ClearCondTestCaseID() {
	m.cond_test_case_id = nil
	m.clearedFields[cond.FieldCondTestCaseID] = struct{}{}
}

// CondTestCaseIDCleared returns if the "cond_test_case_id" field was cleared in this mutation.
func (m *CondMutation) CondTestCaseIDCleared() bool {
	_, ok := m.clearedFields[cond.FieldCondTestCaseID]
	return ok
}

// ResetCondTestCaseID resets all changes to the "cond_test_case_id" field.
func (m *CondMutation) ResetCondTestCaseID() {
	m.cond_test_case_id = nil
	delete(m.clearedFields, cond.FieldCondTestCaseID)
}

// SetArgumentMap sets the "argument_map" field.
func (m *CondMutation) SetArgumentMap(s string) {
	m.argument_map = &s
}

// ArgumentMap returns the value of the "argument_map" field in the mutation.
func (m *CondMutation) ArgumentMap() (r string, exists bool) {
	v := m.argument_map
	if v == nil {
		return
	}
	return *v, true
}

// OldArgumentMap returns the old "argument_map" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldArgumentMap(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgumentMap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgumentMap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgumentMap: %w", err)
	}
	return oldValue.ArgumentMap, nil
}

// ClearArgumentMap clears the value of the "argument_map" field.
func (m *CondMutation) ClearArgumentMap() {
	m.argument_map = nil
	m.clearedFields[cond.FieldArgumentMap] = struct{}{}
}

// ArgumentMapCleared returns if the "argument_map" field was cleared in this mutation.
func (m *CondMutation) ArgumentMapCleared() bool {
	_, ok := m.clearedFields[cond.FieldArgumentMap]
	return ok
}

// ResetArgumentMap resets all changes to the "argument_map" field.
func (m *CondMutation) ResetArgumentMap() {
	m.argument_map = nil
	delete(m.clearedFields, cond.FieldArgumentMap)
}

// SetIndex sets the "index" field.
func (m *CondMutation) SetIndex(u uint32) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *CondMutation) Index() (r uint32, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Cond entity.
// If the Cond object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CondMutation) OldIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *CondMutation) AddIndex(u int32) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *CondMutation) AddedIndex() (r int32, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *CondMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[cond.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *CondMutation) IndexCleared() bool {
	_, ok := m.clearedFields[cond.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *CondMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, cond.FieldIndex)
}

// Where appends a list predicates to the CondMutation builder.
func (m *CondMutation) Where(ps ...predicate.Cond) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CondMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cond).
func (m *CondMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CondMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, cond.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cond.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cond.FieldDeletedAt)
	}
	if m.cond_type != nil {
		fields = append(fields, cond.FieldCondType)
	}
	if m.test_case_id != nil {
		fields = append(fields, cond.FieldTestCaseID)
	}
	if m.cond_test_case_id != nil {
		fields = append(fields, cond.FieldCondTestCaseID)
	}
	if m.argument_map != nil {
		fields = append(fields, cond.FieldArgumentMap)
	}
	if m.index != nil {
		fields = append(fields, cond.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CondMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cond.FieldCreatedAt:
		return m.CreatedAt()
	case cond.FieldUpdatedAt:
		return m.UpdatedAt()
	case cond.FieldDeletedAt:
		return m.DeletedAt()
	case cond.FieldCondType:
		return m.CondType()
	case cond.FieldTestCaseID:
		return m.TestCaseID()
	case cond.FieldCondTestCaseID:
		return m.CondTestCaseID()
	case cond.FieldArgumentMap:
		return m.ArgumentMap()
	case cond.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CondMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cond.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cond.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cond.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cond.FieldCondType:
		return m.OldCondType(ctx)
	case cond.FieldTestCaseID:
		return m.OldTestCaseID(ctx)
	case cond.FieldCondTestCaseID:
		return m.OldCondTestCaseID(ctx)
	case cond.FieldArgumentMap:
		return m.OldArgumentMap(ctx)
	case cond.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown Cond field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CondMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cond.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cond.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cond.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cond.FieldCondType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondType(v)
		return nil
	case cond.FieldTestCaseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseID(v)
		return nil
	case cond.FieldCondTestCaseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondTestCaseID(v)
		return nil
	case cond.FieldArgumentMap:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgumentMap(v)
		return nil
	case cond.FieldIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Cond field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CondMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, cond.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, cond.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, cond.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, cond.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CondMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cond.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cond.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cond.FieldDeletedAt:
		return m.AddedDeletedAt()
	case cond.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CondMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cond.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cond.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cond.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case cond.FieldIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Cond numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CondMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cond.FieldCondType) {
		fields = append(fields, cond.FieldCondType)
	}
	if m.FieldCleared(cond.FieldTestCaseID) {
		fields = append(fields, cond.FieldTestCaseID)
	}
	if m.FieldCleared(cond.FieldCondTestCaseID) {
		fields = append(fields, cond.FieldCondTestCaseID)
	}
	if m.FieldCleared(cond.FieldArgumentMap) {
		fields = append(fields, cond.FieldArgumentMap)
	}
	if m.FieldCleared(cond.FieldIndex) {
		fields = append(fields, cond.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CondMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CondMutation) ClearField(name string) error {
	switch name {
	case cond.FieldCondType:
		m.ClearCondType()
		return nil
	case cond.FieldTestCaseID:
		m.ClearTestCaseID()
		return nil
	case cond.FieldCondTestCaseID:
		m.ClearCondTestCaseID()
		return nil
	case cond.FieldArgumentMap:
		m.ClearArgumentMap()
		return nil
	case cond.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown Cond nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CondMutation) ResetField(name string) error {
	switch name {
	case cond.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cond.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cond.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cond.FieldCondType:
		m.ResetCondType()
		return nil
	case cond.FieldTestCaseID:
		m.ResetTestCaseID()
		return nil
	case cond.FieldCondTestCaseID:
		m.ResetCondTestCaseID()
		return nil
	case cond.FieldArgumentMap:
		m.ResetArgumentMap()
		return nil
	case cond.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown Cond field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CondMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CondMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CondMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CondMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CondMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CondMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CondMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cond unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CondMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cond edge %s", name)
}

// ModuleMutation represents an operation that mutates the Module nodes in the graph.
type ModuleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	name          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Module, error)
	predicates    []predicate.Module
}

var _ ent.Mutation = (*ModuleMutation)(nil)

// moduleOption allows management of the mutation configuration using functional options.
type moduleOption func(*ModuleMutation)

// newModuleMutation creates new mutation for the Module entity.
func newModuleMutation(c config, op Op, opts ...moduleOption) *ModuleMutation {
	m := &ModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModuleID sets the ID field of the mutation.
func withModuleID(id uuid.UUID) moduleOption {
	return func(m *ModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Module
		)
		m.oldValue = func(ctx context.Context) (*Module, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Module.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModule sets the old Module of the mutation.
func withModule(node *Module) moduleOption {
	return func(m *ModuleMutation) {
		m.oldValue = func(context.Context) (*Module, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Module entities.
func (m *ModuleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModuleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModuleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Module.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModuleMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModuleMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ModuleMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ModuleMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModuleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModuleMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModuleMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ModuleMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ModuleMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ModuleMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ModuleMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ModuleMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ModuleMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ModuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ModuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModuleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ModuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ModuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Module entity.
// If the Module object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ModuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[module.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ModuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[module.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ModuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, module.FieldDescription)
}

// Where appends a list predicates to the ModuleMutation builder.
func (m *ModuleMutation) Where(ps ...predicate.Module) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Module).
func (m *ModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModuleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, module.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, module.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, module.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, module.FieldName)
	}
	if m.description != nil {
		fields = append(fields, module.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case module.FieldCreatedAt:
		return m.CreatedAt()
	case module.FieldUpdatedAt:
		return m.UpdatedAt()
	case module.FieldDeletedAt:
		return m.DeletedAt()
	case module.FieldName:
		return m.Name()
	case module.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case module.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case module.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case module.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case module.FieldName:
		return m.OldName(ctx)
	case module.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Module field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case module.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case module.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case module.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case module.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case module.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModuleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, module.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, module.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, module.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case module.FieldCreatedAt:
		return m.AddedCreatedAt()
	case module.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case module.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case module.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case module.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case module.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Module numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(module.FieldDescription) {
		fields = append(fields, module.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModuleMutation) ClearField(name string) error {
	switch name {
	case module.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Module nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModuleMutation) ResetField(name string) error {
	switch name {
	case module.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case module.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case module.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case module.FieldName:
		m.ResetName()
		return nil
	case module.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Module unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Module edge %s", name)
}

// PlanRelatedTestCaseMutation represents an operation that mutates the PlanRelatedTestCase nodes in the graph.
type PlanRelatedTestCaseMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	test_plan_id     *uuid.UUID
	test_case_id     *uuid.UUID
	test_case_output *string
	description      *string
	test_user_id     *uuid.UUID
	run_duration     *uint32
	addrun_duration  *int32
	test_case_result *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*PlanRelatedTestCase, error)
	predicates       []predicate.PlanRelatedTestCase
}

var _ ent.Mutation = (*PlanRelatedTestCaseMutation)(nil)

// planrelatedtestcaseOption allows management of the mutation configuration using functional options.
type planrelatedtestcaseOption func(*PlanRelatedTestCaseMutation)

// newPlanRelatedTestCaseMutation creates new mutation for the PlanRelatedTestCase entity.
func newPlanRelatedTestCaseMutation(c config, op Op, opts ...planrelatedtestcaseOption) *PlanRelatedTestCaseMutation {
	m := &PlanRelatedTestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypePlanRelatedTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanRelatedTestCaseID sets the ID field of the mutation.
func withPlanRelatedTestCaseID(id uuid.UUID) planrelatedtestcaseOption {
	return func(m *PlanRelatedTestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanRelatedTestCase
		)
		m.oldValue = func(ctx context.Context) (*PlanRelatedTestCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanRelatedTestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanRelatedTestCase sets the old PlanRelatedTestCase of the mutation.
func withPlanRelatedTestCase(node *PlanRelatedTestCase) planrelatedtestcaseOption {
	return func(m *PlanRelatedTestCaseMutation) {
		m.oldValue = func(context.Context) (*PlanRelatedTestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanRelatedTestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanRelatedTestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanRelatedTestCase entities.
func (m *PlanRelatedTestCaseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanRelatedTestCaseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanRelatedTestCaseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanRelatedTestCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanRelatedTestCaseMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanRelatedTestCaseMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *PlanRelatedTestCaseMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanRelatedTestCaseMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanRelatedTestCaseMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanRelatedTestCaseMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *PlanRelatedTestCaseMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanRelatedTestCaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanRelatedTestCaseMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanRelatedTestCaseMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *PlanRelatedTestCaseMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanRelatedTestCaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTestPlanID sets the "test_plan_id" field.
func (m *PlanRelatedTestCaseMutation) SetTestPlanID(u uuid.UUID) {
	m.test_plan_id = &u
}

// TestPlanID returns the value of the "test_plan_id" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestPlanID() (r uuid.UUID, exists bool) {
	v := m.test_plan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestPlanID returns the old "test_plan_id" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestPlanID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestPlanID: %w", err)
	}
	return oldValue.TestPlanID, nil
}

// ClearTestPlanID clears the value of the "test_plan_id" field.
func (m *PlanRelatedTestCaseMutation) ClearTestPlanID() {
	m.test_plan_id = nil
	m.clearedFields[planrelatedtestcase.FieldTestPlanID] = struct{}{}
}

// TestPlanIDCleared returns if the "test_plan_id" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestPlanIDCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestPlanID]
	return ok
}

// ResetTestPlanID resets all changes to the "test_plan_id" field.
func (m *PlanRelatedTestCaseMutation) ResetTestPlanID() {
	m.test_plan_id = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestPlanID)
}

// SetTestCaseID sets the "test_case_id" field.
func (m *PlanRelatedTestCaseMutation) SetTestCaseID(u uuid.UUID) {
	m.test_case_id = &u
}

// TestCaseID returns the value of the "test_case_id" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseID() (r uuid.UUID, exists bool) {
	v := m.test_case_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseID returns the old "test_case_id" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestCaseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseID: %w", err)
	}
	return oldValue.TestCaseID, nil
}

// ClearTestCaseID clears the value of the "test_case_id" field.
func (m *PlanRelatedTestCaseMutation) ClearTestCaseID() {
	m.test_case_id = nil
	m.clearedFields[planrelatedtestcase.FieldTestCaseID] = struct{}{}
}

// TestCaseIDCleared returns if the "test_case_id" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseIDCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestCaseID]
	return ok
}

// ResetTestCaseID resets all changes to the "test_case_id" field.
func (m *PlanRelatedTestCaseMutation) ResetTestCaseID() {
	m.test_case_id = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestCaseID)
}

// SetTestCaseOutput sets the "test_case_output" field.
func (m *PlanRelatedTestCaseMutation) SetTestCaseOutput(s string) {
	m.test_case_output = &s
}

// TestCaseOutput returns the value of the "test_case_output" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseOutput() (r string, exists bool) {
	v := m.test_case_output
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseOutput returns the old "test_case_output" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestCaseOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseOutput: %w", err)
	}
	return oldValue.TestCaseOutput, nil
}

// ClearTestCaseOutput clears the value of the "test_case_output" field.
func (m *PlanRelatedTestCaseMutation) ClearTestCaseOutput() {
	m.test_case_output = nil
	m.clearedFields[planrelatedtestcase.FieldTestCaseOutput] = struct{}{}
}

// TestCaseOutputCleared returns if the "test_case_output" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseOutputCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestCaseOutput]
	return ok
}

// ResetTestCaseOutput resets all changes to the "test_case_output" field.
func (m *PlanRelatedTestCaseMutation) ResetTestCaseOutput() {
	m.test_case_output = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestCaseOutput)
}

// SetDescription sets the "description" field.
func (m *PlanRelatedTestCaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanRelatedTestCaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanRelatedTestCaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[planrelatedtestcase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanRelatedTestCaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, planrelatedtestcase.FieldDescription)
}

// SetTestUserID sets the "test_user_id" field.
func (m *PlanRelatedTestCaseMutation) SetTestUserID(u uuid.UUID) {
	m.test_user_id = &u
}

// TestUserID returns the value of the "test_user_id" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestUserID() (r uuid.UUID, exists bool) {
	v := m.test_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestUserID returns the old "test_user_id" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestUserID: %w", err)
	}
	return oldValue.TestUserID, nil
}

// ClearTestUserID clears the value of the "test_user_id" field.
func (m *PlanRelatedTestCaseMutation) ClearTestUserID() {
	m.test_user_id = nil
	m.clearedFields[planrelatedtestcase.FieldTestUserID] = struct{}{}
}

// TestUserIDCleared returns if the "test_user_id" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestUserIDCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestUserID]
	return ok
}

// ResetTestUserID resets all changes to the "test_user_id" field.
func (m *PlanRelatedTestCaseMutation) ResetTestUserID() {
	m.test_user_id = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestUserID)
}

// SetRunDuration sets the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) SetRunDuration(u uint32) {
	m.run_duration = &u
	m.addrun_duration = nil
}

// RunDuration returns the value of the "run_duration" field in the mutation.
func (m *PlanRelatedTestCaseMutation) RunDuration() (r uint32, exists bool) {
	v := m.run_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldRunDuration returns the old "run_duration" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldRunDuration(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunDuration: %w", err)
	}
	return oldValue.RunDuration, nil
}

// AddRunDuration adds u to the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) AddRunDuration(u int32) {
	if m.addrun_duration != nil {
		*m.addrun_duration += u
	} else {
		m.addrun_duration = &u
	}
}

// AddedRunDuration returns the value that was added to the "run_duration" field in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedRunDuration() (r int32, exists bool) {
	v := m.addrun_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearRunDuration clears the value of the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) ClearRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	m.clearedFields[planrelatedtestcase.FieldRunDuration] = struct{}{}
}

// RunDurationCleared returns if the "run_duration" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) RunDurationCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldRunDuration]
	return ok
}

// ResetRunDuration resets all changes to the "run_duration" field.
func (m *PlanRelatedTestCaseMutation) ResetRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	delete(m.clearedFields, planrelatedtestcase.FieldRunDuration)
}

// SetTestCaseResult sets the "test_case_result" field.
func (m *PlanRelatedTestCaseMutation) SetTestCaseResult(s string) {
	m.test_case_result = &s
}

// TestCaseResult returns the value of the "test_case_result" field in the mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseResult() (r string, exists bool) {
	v := m.test_case_result
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseResult returns the old "test_case_result" field's value of the PlanRelatedTestCase entity.
// If the PlanRelatedTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRelatedTestCaseMutation) OldTestCaseResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseResult: %w", err)
	}
	return oldValue.TestCaseResult, nil
}

// ClearTestCaseResult clears the value of the "test_case_result" field.
func (m *PlanRelatedTestCaseMutation) ClearTestCaseResult() {
	m.test_case_result = nil
	m.clearedFields[planrelatedtestcase.FieldTestCaseResult] = struct{}{}
}

// TestCaseResultCleared returns if the "test_case_result" field was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) TestCaseResultCleared() bool {
	_, ok := m.clearedFields[planrelatedtestcase.FieldTestCaseResult]
	return ok
}

// ResetTestCaseResult resets all changes to the "test_case_result" field.
func (m *PlanRelatedTestCaseMutation) ResetTestCaseResult() {
	m.test_case_result = nil
	delete(m.clearedFields, planrelatedtestcase.FieldTestCaseResult)
}

// Where appends a list predicates to the PlanRelatedTestCaseMutation builder.
func (m *PlanRelatedTestCaseMutation) Where(ps ...predicate.PlanRelatedTestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlanRelatedTestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PlanRelatedTestCase).
func (m *PlanRelatedTestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanRelatedTestCaseMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, planrelatedtestcase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planrelatedtestcase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, planrelatedtestcase.FieldDeletedAt)
	}
	if m.test_plan_id != nil {
		fields = append(fields, planrelatedtestcase.FieldTestPlanID)
	}
	if m.test_case_id != nil {
		fields = append(fields, planrelatedtestcase.FieldTestCaseID)
	}
	if m.test_case_output != nil {
		fields = append(fields, planrelatedtestcase.FieldTestCaseOutput)
	}
	if m.description != nil {
		fields = append(fields, planrelatedtestcase.FieldDescription)
	}
	if m.test_user_id != nil {
		fields = append(fields, planrelatedtestcase.FieldTestUserID)
	}
	if m.run_duration != nil {
		fields = append(fields, planrelatedtestcase.FieldRunDuration)
	}
	if m.test_case_result != nil {
		fields = append(fields, planrelatedtestcase.FieldTestCaseResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanRelatedTestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		return m.CreatedAt()
	case planrelatedtestcase.FieldUpdatedAt:
		return m.UpdatedAt()
	case planrelatedtestcase.FieldDeletedAt:
		return m.DeletedAt()
	case planrelatedtestcase.FieldTestPlanID:
		return m.TestPlanID()
	case planrelatedtestcase.FieldTestCaseID:
		return m.TestCaseID()
	case planrelatedtestcase.FieldTestCaseOutput:
		return m.TestCaseOutput()
	case planrelatedtestcase.FieldDescription:
		return m.Description()
	case planrelatedtestcase.FieldTestUserID:
		return m.TestUserID()
	case planrelatedtestcase.FieldRunDuration:
		return m.RunDuration()
	case planrelatedtestcase.FieldTestCaseResult:
		return m.TestCaseResult()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanRelatedTestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planrelatedtestcase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planrelatedtestcase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case planrelatedtestcase.FieldTestPlanID:
		return m.OldTestPlanID(ctx)
	case planrelatedtestcase.FieldTestCaseID:
		return m.OldTestCaseID(ctx)
	case planrelatedtestcase.FieldTestCaseOutput:
		return m.OldTestCaseOutput(ctx)
	case planrelatedtestcase.FieldDescription:
		return m.OldDescription(ctx)
	case planrelatedtestcase.FieldTestUserID:
		return m.OldTestUserID(ctx)
	case planrelatedtestcase.FieldRunDuration:
		return m.OldRunDuration(ctx)
	case planrelatedtestcase.FieldTestCaseResult:
		return m.OldTestCaseResult(ctx)
	}
	return nil, fmt.Errorf("unknown PlanRelatedTestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRelatedTestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planrelatedtestcase.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planrelatedtestcase.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case planrelatedtestcase.FieldTestPlanID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestPlanID(v)
		return nil
	case planrelatedtestcase.FieldTestCaseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseID(v)
		return nil
	case planrelatedtestcase.FieldTestCaseOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseOutput(v)
		return nil
	case planrelatedtestcase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case planrelatedtestcase.FieldTestUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestUserID(v)
		return nil
	case planrelatedtestcase.FieldRunDuration:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunDuration(v)
		return nil
	case planrelatedtestcase.FieldTestCaseResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseResult(v)
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanRelatedTestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, planrelatedtestcase.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, planrelatedtestcase.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, planrelatedtestcase.FieldDeletedAt)
	}
	if m.addrun_duration != nil {
		fields = append(fields, planrelatedtestcase.FieldRunDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanRelatedTestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		return m.AddedCreatedAt()
	case planrelatedtestcase.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case planrelatedtestcase.FieldDeletedAt:
		return m.AddedDeletedAt()
	case planrelatedtestcase.FieldRunDuration:
		return m.AddedRunDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRelatedTestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case planrelatedtestcase.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case planrelatedtestcase.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case planrelatedtestcase.FieldRunDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunDuration(v)
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanRelatedTestCaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planrelatedtestcase.FieldTestPlanID) {
		fields = append(fields, planrelatedtestcase.FieldTestPlanID)
	}
	if m.FieldCleared(planrelatedtestcase.FieldTestCaseID) {
		fields = append(fields, planrelatedtestcase.FieldTestCaseID)
	}
	if m.FieldCleared(planrelatedtestcase.FieldTestCaseOutput) {
		fields = append(fields, planrelatedtestcase.FieldTestCaseOutput)
	}
	if m.FieldCleared(planrelatedtestcase.FieldDescription) {
		fields = append(fields, planrelatedtestcase.FieldDescription)
	}
	if m.FieldCleared(planrelatedtestcase.FieldTestUserID) {
		fields = append(fields, planrelatedtestcase.FieldTestUserID)
	}
	if m.FieldCleared(planrelatedtestcase.FieldRunDuration) {
		fields = append(fields, planrelatedtestcase.FieldRunDuration)
	}
	if m.FieldCleared(planrelatedtestcase.FieldTestCaseResult) {
		fields = append(fields, planrelatedtestcase.FieldTestCaseResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ClearField(name string) error {
	switch name {
	case planrelatedtestcase.FieldTestPlanID:
		m.ClearTestPlanID()
		return nil
	case planrelatedtestcase.FieldTestCaseID:
		m.ClearTestCaseID()
		return nil
	case planrelatedtestcase.FieldTestCaseOutput:
		m.ClearTestCaseOutput()
		return nil
	case planrelatedtestcase.FieldDescription:
		m.ClearDescription()
		return nil
	case planrelatedtestcase.FieldTestUserID:
		m.ClearTestUserID()
		return nil
	case planrelatedtestcase.FieldRunDuration:
		m.ClearRunDuration()
		return nil
	case planrelatedtestcase.FieldTestCaseResult:
		m.ClearTestCaseResult()
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ResetField(name string) error {
	switch name {
	case planrelatedtestcase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planrelatedtestcase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planrelatedtestcase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case planrelatedtestcase.FieldTestPlanID:
		m.ResetTestPlanID()
		return nil
	case planrelatedtestcase.FieldTestCaseID:
		m.ResetTestCaseID()
		return nil
	case planrelatedtestcase.FieldTestCaseOutput:
		m.ResetTestCaseOutput()
		return nil
	case planrelatedtestcase.FieldDescription:
		m.ResetDescription()
		return nil
	case planrelatedtestcase.FieldTestUserID:
		m.ResetTestUserID()
		return nil
	case planrelatedtestcase.FieldRunDuration:
		m.ResetRunDuration()
		return nil
	case planrelatedtestcase.FieldTestCaseResult:
		m.ResetTestCaseResult()
		return nil
	}
	return fmt.Errorf("unknown PlanRelatedTestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanRelatedTestCaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanRelatedTestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanRelatedTestCaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanRelatedTestCaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PlanRelatedTestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanRelatedTestCaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PlanRelatedTestCase edge %s", name)
}

// TestCaseMutation represents an operation that mutates the TestCase nodes in the graph.
type TestCaseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	name                 *string
	description          *string
	module_id            *uuid.UUID
	api_id               *uuid.UUID
	arguments            *string
	arg_type_description *string
	expectation_result   *string
	test_case_type       *string
	deprecated           *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*TestCase, error)
	predicates           []predicate.TestCase
}

var _ ent.Mutation = (*TestCaseMutation)(nil)

// testcaseOption allows management of the mutation configuration using functional options.
type testcaseOption func(*TestCaseMutation)

// newTestCaseMutation creates new mutation for the TestCase entity.
func newTestCaseMutation(c config, op Op, opts ...testcaseOption) *TestCaseMutation {
	m := &TestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestCaseID sets the ID field of the mutation.
func withTestCaseID(id uuid.UUID) testcaseOption {
	return func(m *TestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *TestCase
		)
		m.oldValue = func(ctx context.Context) (*TestCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestCase sets the old TestCase of the mutation.
func withTestCase(node *TestCase) testcaseOption {
	return func(m *TestCaseMutation) {
		m.oldValue = func(context.Context) (*TestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestCase entities.
func (m *TestCaseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestCaseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestCaseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TestCaseMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestCaseMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TestCaseMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TestCaseMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestCaseMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestCaseMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestCaseMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TestCaseMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TestCaseMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestCaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TestCaseMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TestCaseMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TestCaseMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TestCaseMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TestCaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *TestCaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestCaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TestCaseMutation) ClearName() {
	m.name = nil
	m.clearedFields[testcase.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TestCaseMutation) NameCleared() bool {
	_, ok := m.clearedFields[testcase.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TestCaseMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, testcase.FieldName)
}

// SetDescription sets the "description" field.
func (m *TestCaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TestCaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TestCaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[testcase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TestCaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[testcase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TestCaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, testcase.FieldDescription)
}

// SetModuleID sets the "module_id" field.
func (m *TestCaseMutation) SetModuleID(u uuid.UUID) {
	m.module_id = &u
}

// ModuleID returns the value of the "module_id" field in the mutation.
func (m *TestCaseMutation) ModuleID() (r uuid.UUID, exists bool) {
	v := m.module_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleID returns the old "module_id" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldModuleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleID: %w", err)
	}
	return oldValue.ModuleID, nil
}

// ClearModuleID clears the value of the "module_id" field.
func (m *TestCaseMutation) ClearModuleID() {
	m.module_id = nil
	m.clearedFields[testcase.FieldModuleID] = struct{}{}
}

// ModuleIDCleared returns if the "module_id" field was cleared in this mutation.
func (m *TestCaseMutation) ModuleIDCleared() bool {
	_, ok := m.clearedFields[testcase.FieldModuleID]
	return ok
}

// ResetModuleID resets all changes to the "module_id" field.
func (m *TestCaseMutation) ResetModuleID() {
	m.module_id = nil
	delete(m.clearedFields, testcase.FieldModuleID)
}

// SetAPIID sets the "api_id" field.
func (m *TestCaseMutation) SetAPIID(u uuid.UUID) {
	m.api_id = &u
}

// APIID returns the value of the "api_id" field in the mutation.
func (m *TestCaseMutation) APIID() (r uuid.UUID, exists bool) {
	v := m.api_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIID returns the old "api_id" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldAPIID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIID: %w", err)
	}
	return oldValue.APIID, nil
}

// ClearAPIID clears the value of the "api_id" field.
func (m *TestCaseMutation) ClearAPIID() {
	m.api_id = nil
	m.clearedFields[testcase.FieldAPIID] = struct{}{}
}

// APIIDCleared returns if the "api_id" field was cleared in this mutation.
func (m *TestCaseMutation) APIIDCleared() bool {
	_, ok := m.clearedFields[testcase.FieldAPIID]
	return ok
}

// ResetAPIID resets all changes to the "api_id" field.
func (m *TestCaseMutation) ResetAPIID() {
	m.api_id = nil
	delete(m.clearedFields, testcase.FieldAPIID)
}

// SetArguments sets the "arguments" field.
func (m *TestCaseMutation) SetArguments(s string) {
	m.arguments = &s
}

// Arguments returns the value of the "arguments" field in the mutation.
func (m *TestCaseMutation) Arguments() (r string, exists bool) {
	v := m.arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldArguments returns the old "arguments" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldArguments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArguments: %w", err)
	}
	return oldValue.Arguments, nil
}

// ClearArguments clears the value of the "arguments" field.
func (m *TestCaseMutation) ClearArguments() {
	m.arguments = nil
	m.clearedFields[testcase.FieldArguments] = struct{}{}
}

// ArgumentsCleared returns if the "arguments" field was cleared in this mutation.
func (m *TestCaseMutation) ArgumentsCleared() bool {
	_, ok := m.clearedFields[testcase.FieldArguments]
	return ok
}

// ResetArguments resets all changes to the "arguments" field.
func (m *TestCaseMutation) ResetArguments() {
	m.arguments = nil
	delete(m.clearedFields, testcase.FieldArguments)
}

// SetArgTypeDescription sets the "arg_type_description" field.
func (m *TestCaseMutation) SetArgTypeDescription(s string) {
	m.arg_type_description = &s
}

// ArgTypeDescription returns the value of the "arg_type_description" field in the mutation.
func (m *TestCaseMutation) ArgTypeDescription() (r string, exists bool) {
	v := m.arg_type_description
	if v == nil {
		return
	}
	return *v, true
}

// OldArgTypeDescription returns the old "arg_type_description" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldArgTypeDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgTypeDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgTypeDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgTypeDescription: %w", err)
	}
	return oldValue.ArgTypeDescription, nil
}

// ClearArgTypeDescription clears the value of the "arg_type_description" field.
func (m *TestCaseMutation) ClearArgTypeDescription() {
	m.arg_type_description = nil
	m.clearedFields[testcase.FieldArgTypeDescription] = struct{}{}
}

// ArgTypeDescriptionCleared returns if the "arg_type_description" field was cleared in this mutation.
func (m *TestCaseMutation) ArgTypeDescriptionCleared() bool {
	_, ok := m.clearedFields[testcase.FieldArgTypeDescription]
	return ok
}

// ResetArgTypeDescription resets all changes to the "arg_type_description" field.
func (m *TestCaseMutation) ResetArgTypeDescription() {
	m.arg_type_description = nil
	delete(m.clearedFields, testcase.FieldArgTypeDescription)
}

// SetExpectationResult sets the "expectation_result" field.
func (m *TestCaseMutation) SetExpectationResult(s string) {
	m.expectation_result = &s
}

// ExpectationResult returns the value of the "expectation_result" field in the mutation.
func (m *TestCaseMutation) ExpectationResult() (r string, exists bool) {
	v := m.expectation_result
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectationResult returns the old "expectation_result" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldExpectationResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectationResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectationResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectationResult: %w", err)
	}
	return oldValue.ExpectationResult, nil
}

// ClearExpectationResult clears the value of the "expectation_result" field.
func (m *TestCaseMutation) ClearExpectationResult() {
	m.expectation_result = nil
	m.clearedFields[testcase.FieldExpectationResult] = struct{}{}
}

// ExpectationResultCleared returns if the "expectation_result" field was cleared in this mutation.
func (m *TestCaseMutation) ExpectationResultCleared() bool {
	_, ok := m.clearedFields[testcase.FieldExpectationResult]
	return ok
}

// ResetExpectationResult resets all changes to the "expectation_result" field.
func (m *TestCaseMutation) ResetExpectationResult() {
	m.expectation_result = nil
	delete(m.clearedFields, testcase.FieldExpectationResult)
}

// SetTestCaseType sets the "test_case_type" field.
func (m *TestCaseMutation) SetTestCaseType(s string) {
	m.test_case_type = &s
}

// TestCaseType returns the value of the "test_case_type" field in the mutation.
func (m *TestCaseMutation) TestCaseType() (r string, exists bool) {
	v := m.test_case_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTestCaseType returns the old "test_case_type" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldTestCaseType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestCaseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestCaseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestCaseType: %w", err)
	}
	return oldValue.TestCaseType, nil
}

// ClearTestCaseType clears the value of the "test_case_type" field.
func (m *TestCaseMutation) ClearTestCaseType() {
	m.test_case_type = nil
	m.clearedFields[testcase.FieldTestCaseType] = struct{}{}
}

// TestCaseTypeCleared returns if the "test_case_type" field was cleared in this mutation.
func (m *TestCaseMutation) TestCaseTypeCleared() bool {
	_, ok := m.clearedFields[testcase.FieldTestCaseType]
	return ok
}

// ResetTestCaseType resets all changes to the "test_case_type" field.
func (m *TestCaseMutation) ResetTestCaseType() {
	m.test_case_type = nil
	delete(m.clearedFields, testcase.FieldTestCaseType)
}

// SetDeprecated sets the "deprecated" field.
func (m *TestCaseMutation) SetDeprecated(b bool) {
	m.deprecated = &b
}

// Deprecated returns the value of the "deprecated" field in the mutation.
func (m *TestCaseMutation) Deprecated() (r bool, exists bool) {
	v := m.deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldDeprecated returns the old "deprecated" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeprecated: %w", err)
	}
	return oldValue.Deprecated, nil
}

// ClearDeprecated clears the value of the "deprecated" field.
func (m *TestCaseMutation) ClearDeprecated() {
	m.deprecated = nil
	m.clearedFields[testcase.FieldDeprecated] = struct{}{}
}

// DeprecatedCleared returns if the "deprecated" field was cleared in this mutation.
func (m *TestCaseMutation) DeprecatedCleared() bool {
	_, ok := m.clearedFields[testcase.FieldDeprecated]
	return ok
}

// ResetDeprecated resets all changes to the "deprecated" field.
func (m *TestCaseMutation) ResetDeprecated() {
	m.deprecated = nil
	delete(m.clearedFields, testcase.FieldDeprecated)
}

// Where appends a list predicates to the TestCaseMutation builder.
func (m *TestCaseMutation) Where(ps ...predicate.TestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestCase).
func (m *TestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestCaseMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, testcase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testcase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, testcase.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, testcase.FieldName)
	}
	if m.description != nil {
		fields = append(fields, testcase.FieldDescription)
	}
	if m.module_id != nil {
		fields = append(fields, testcase.FieldModuleID)
	}
	if m.api_id != nil {
		fields = append(fields, testcase.FieldAPIID)
	}
	if m.arguments != nil {
		fields = append(fields, testcase.FieldArguments)
	}
	if m.arg_type_description != nil {
		fields = append(fields, testcase.FieldArgTypeDescription)
	}
	if m.expectation_result != nil {
		fields = append(fields, testcase.FieldExpectationResult)
	}
	if m.test_case_type != nil {
		fields = append(fields, testcase.FieldTestCaseType)
	}
	if m.deprecated != nil {
		fields = append(fields, testcase.FieldDeprecated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldCreatedAt:
		return m.CreatedAt()
	case testcase.FieldUpdatedAt:
		return m.UpdatedAt()
	case testcase.FieldDeletedAt:
		return m.DeletedAt()
	case testcase.FieldName:
		return m.Name()
	case testcase.FieldDescription:
		return m.Description()
	case testcase.FieldModuleID:
		return m.ModuleID()
	case testcase.FieldAPIID:
		return m.APIID()
	case testcase.FieldArguments:
		return m.Arguments()
	case testcase.FieldArgTypeDescription:
		return m.ArgTypeDescription()
	case testcase.FieldExpectationResult:
		return m.ExpectationResult()
	case testcase.FieldTestCaseType:
		return m.TestCaseType()
	case testcase.FieldDeprecated:
		return m.Deprecated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testcase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testcase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case testcase.FieldName:
		return m.OldName(ctx)
	case testcase.FieldDescription:
		return m.OldDescription(ctx)
	case testcase.FieldModuleID:
		return m.OldModuleID(ctx)
	case testcase.FieldAPIID:
		return m.OldAPIID(ctx)
	case testcase.FieldArguments:
		return m.OldArguments(ctx)
	case testcase.FieldArgTypeDescription:
		return m.OldArgTypeDescription(ctx)
	case testcase.FieldExpectationResult:
		return m.OldExpectationResult(ctx)
	case testcase.FieldTestCaseType:
		return m.OldTestCaseType(ctx)
	case testcase.FieldDeprecated:
		return m.OldDeprecated(ctx)
	}
	return nil, fmt.Errorf("unknown TestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testcase.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testcase.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case testcase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testcase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case testcase.FieldModuleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleID(v)
		return nil
	case testcase.FieldAPIID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIID(v)
		return nil
	case testcase.FieldArguments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArguments(v)
		return nil
	case testcase.FieldArgTypeDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgTypeDescription(v)
		return nil
	case testcase.FieldExpectationResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectationResult(v)
		return nil
	case testcase.FieldTestCaseType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestCaseType(v)
		return nil
	case testcase.FieldDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeprecated(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, testcase.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, testcase.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, testcase.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldCreatedAt:
		return m.AddedCreatedAt()
	case testcase.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case testcase.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case testcase.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case testcase.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestCaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testcase.FieldName) {
		fields = append(fields, testcase.FieldName)
	}
	if m.FieldCleared(testcase.FieldDescription) {
		fields = append(fields, testcase.FieldDescription)
	}
	if m.FieldCleared(testcase.FieldModuleID) {
		fields = append(fields, testcase.FieldModuleID)
	}
	if m.FieldCleared(testcase.FieldAPIID) {
		fields = append(fields, testcase.FieldAPIID)
	}
	if m.FieldCleared(testcase.FieldArguments) {
		fields = append(fields, testcase.FieldArguments)
	}
	if m.FieldCleared(testcase.FieldArgTypeDescription) {
		fields = append(fields, testcase.FieldArgTypeDescription)
	}
	if m.FieldCleared(testcase.FieldExpectationResult) {
		fields = append(fields, testcase.FieldExpectationResult)
	}
	if m.FieldCleared(testcase.FieldTestCaseType) {
		fields = append(fields, testcase.FieldTestCaseType)
	}
	if m.FieldCleared(testcase.FieldDeprecated) {
		fields = append(fields, testcase.FieldDeprecated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestCaseMutation) ClearField(name string) error {
	switch name {
	case testcase.FieldName:
		m.ClearName()
		return nil
	case testcase.FieldDescription:
		m.ClearDescription()
		return nil
	case testcase.FieldModuleID:
		m.ClearModuleID()
		return nil
	case testcase.FieldAPIID:
		m.ClearAPIID()
		return nil
	case testcase.FieldArguments:
		m.ClearArguments()
		return nil
	case testcase.FieldArgTypeDescription:
		m.ClearArgTypeDescription()
		return nil
	case testcase.FieldExpectationResult:
		m.ClearExpectationResult()
		return nil
	case testcase.FieldTestCaseType:
		m.ClearTestCaseType()
		return nil
	case testcase.FieldDeprecated:
		m.ClearDeprecated()
		return nil
	}
	return fmt.Errorf("unknown TestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestCaseMutation) ResetField(name string) error {
	switch name {
	case testcase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testcase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testcase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case testcase.FieldName:
		m.ResetName()
		return nil
	case testcase.FieldDescription:
		m.ResetDescription()
		return nil
	case testcase.FieldModuleID:
		m.ResetModuleID()
		return nil
	case testcase.FieldAPIID:
		m.ResetAPIID()
		return nil
	case testcase.FieldArguments:
		m.ResetArguments()
		return nil
	case testcase.FieldArgTypeDescription:
		m.ResetArgTypeDescription()
		return nil
	case testcase.FieldExpectationResult:
		m.ResetExpectationResult()
		return nil
	case testcase.FieldTestCaseType:
		m.ResetTestCaseType()
		return nil
	case testcase.FieldDeprecated:
		m.ResetDeprecated()
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestCaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestCaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestCaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestCaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestCaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestCase edge %s", name)
}

// TestPlanMutation represents an operation that mutates the TestPlan nodes in the graph.
type TestPlanMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	created_at                  *uint32
	addcreated_at               *int32
	updated_at                  *uint32
	addupdated_at               *int32
	deleted_at                  *uint32
	adddeleted_at               *int32
	name                        *string
	state                       *string
	owner_id                    *uuid.UUID
	responsible_user_id         *uuid.UUID
	failed_test_cases_count     *uint32
	addfailed_test_cases_count  *int32
	passed_test_cases_count     *uint32
	addpassed_test_cases_count  *int32
	skipped_test_cases_count    *uint32
	addskipped_test_cases_count *int32
	run_duration                *uint32
	addrun_duration             *int32
	deadline                    *uint32
	adddeadline                 *int32
	test_result                 *string
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*TestPlan, error)
	predicates                  []predicate.TestPlan
}

var _ ent.Mutation = (*TestPlanMutation)(nil)

// testplanOption allows management of the mutation configuration using functional options.
type testplanOption func(*TestPlanMutation)

// newTestPlanMutation creates new mutation for the TestPlan entity.
func newTestPlanMutation(c config, op Op, opts ...testplanOption) *TestPlanMutation {
	m := &TestPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeTestPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestPlanID sets the ID field of the mutation.
func withTestPlanID(id uuid.UUID) testplanOption {
	return func(m *TestPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *TestPlan
		)
		m.oldValue = func(ctx context.Context) (*TestPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestPlan sets the old TestPlan of the mutation.
func withTestPlan(node *TestPlan) testplanOption {
	return func(m *TestPlanMutation) {
		m.oldValue = func(context.Context) (*TestPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestPlan entities.
func (m *TestPlanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestPlanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestPlanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TestPlanMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestPlanMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TestPlanMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TestPlanMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestPlanMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestPlanMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestPlanMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TestPlanMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TestPlanMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TestPlanMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TestPlanMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TestPlanMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TestPlanMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TestPlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *TestPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TestPlanMutation) ClearName() {
	m.name = nil
	m.clearedFields[testplan.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TestPlanMutation) NameCleared() bool {
	_, ok := m.clearedFields[testplan.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TestPlanMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, testplan.FieldName)
}

// SetState sets the "state" field.
func (m *TestPlanMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *TestPlanMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *TestPlanMutation) ClearState() {
	m.state = nil
	m.clearedFields[testplan.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *TestPlanMutation) StateCleared() bool {
	_, ok := m.clearedFields[testplan.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *TestPlanMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, testplan.FieldState)
}

// SetOwnerID sets the "owner_id" field.
func (m *TestPlanMutation) SetOwnerID(u uuid.UUID) {
	m.owner_id = &u
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TestPlanMutation) OwnerID() (r uuid.UUID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldOwnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TestPlanMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[testplan.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TestPlanMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[testplan.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TestPlanMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, testplan.FieldOwnerID)
}

// SetResponsibleUserID sets the "responsible_user_id" field.
func (m *TestPlanMutation) SetResponsibleUserID(u uuid.UUID) {
	m.responsible_user_id = &u
}

// ResponsibleUserID returns the value of the "responsible_user_id" field in the mutation.
func (m *TestPlanMutation) ResponsibleUserID() (r uuid.UUID, exists bool) {
	v := m.responsible_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibleUserID returns the old "responsible_user_id" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldResponsibleUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibleUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibleUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibleUserID: %w", err)
	}
	return oldValue.ResponsibleUserID, nil
}

// ClearResponsibleUserID clears the value of the "responsible_user_id" field.
func (m *TestPlanMutation) ClearResponsibleUserID() {
	m.responsible_user_id = nil
	m.clearedFields[testplan.FieldResponsibleUserID] = struct{}{}
}

// ResponsibleUserIDCleared returns if the "responsible_user_id" field was cleared in this mutation.
func (m *TestPlanMutation) ResponsibleUserIDCleared() bool {
	_, ok := m.clearedFields[testplan.FieldResponsibleUserID]
	return ok
}

// ResetResponsibleUserID resets all changes to the "responsible_user_id" field.
func (m *TestPlanMutation) ResetResponsibleUserID() {
	m.responsible_user_id = nil
	delete(m.clearedFields, testplan.FieldResponsibleUserID)
}

// SetFailedTestCasesCount sets the "failed_test_cases_count" field.
func (m *TestPlanMutation) SetFailedTestCasesCount(u uint32) {
	m.failed_test_cases_count = &u
	m.addfailed_test_cases_count = nil
}

// FailedTestCasesCount returns the value of the "failed_test_cases_count" field in the mutation.
func (m *TestPlanMutation) FailedTestCasesCount() (r uint32, exists bool) {
	v := m.failed_test_cases_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedTestCasesCount returns the old "failed_test_cases_count" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldFailedTestCasesCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedTestCasesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedTestCasesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedTestCasesCount: %w", err)
	}
	return oldValue.FailedTestCasesCount, nil
}

// AddFailedTestCasesCount adds u to the "failed_test_cases_count" field.
func (m *TestPlanMutation) AddFailedTestCasesCount(u int32) {
	if m.addfailed_test_cases_count != nil {
		*m.addfailed_test_cases_count += u
	} else {
		m.addfailed_test_cases_count = &u
	}
}

// AddedFailedTestCasesCount returns the value that was added to the "failed_test_cases_count" field in this mutation.
func (m *TestPlanMutation) AddedFailedTestCasesCount() (r int32, exists bool) {
	v := m.addfailed_test_cases_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearFailedTestCasesCount clears the value of the "failed_test_cases_count" field.
func (m *TestPlanMutation) ClearFailedTestCasesCount() {
	m.failed_test_cases_count = nil
	m.addfailed_test_cases_count = nil
	m.clearedFields[testplan.FieldFailedTestCasesCount] = struct{}{}
}

// FailedTestCasesCountCleared returns if the "failed_test_cases_count" field was cleared in this mutation.
func (m *TestPlanMutation) FailedTestCasesCountCleared() bool {
	_, ok := m.clearedFields[testplan.FieldFailedTestCasesCount]
	return ok
}

// ResetFailedTestCasesCount resets all changes to the "failed_test_cases_count" field.
func (m *TestPlanMutation) ResetFailedTestCasesCount() {
	m.failed_test_cases_count = nil
	m.addfailed_test_cases_count = nil
	delete(m.clearedFields, testplan.FieldFailedTestCasesCount)
}

// SetPassedTestCasesCount sets the "passed_test_cases_count" field.
func (m *TestPlanMutation) SetPassedTestCasesCount(u uint32) {
	m.passed_test_cases_count = &u
	m.addpassed_test_cases_count = nil
}

// PassedTestCasesCount returns the value of the "passed_test_cases_count" field in the mutation.
func (m *TestPlanMutation) PassedTestCasesCount() (r uint32, exists bool) {
	v := m.passed_test_cases_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPassedTestCasesCount returns the old "passed_test_cases_count" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldPassedTestCasesCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassedTestCasesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassedTestCasesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassedTestCasesCount: %w", err)
	}
	return oldValue.PassedTestCasesCount, nil
}

// AddPassedTestCasesCount adds u to the "passed_test_cases_count" field.
func (m *TestPlanMutation) AddPassedTestCasesCount(u int32) {
	if m.addpassed_test_cases_count != nil {
		*m.addpassed_test_cases_count += u
	} else {
		m.addpassed_test_cases_count = &u
	}
}

// AddedPassedTestCasesCount returns the value that was added to the "passed_test_cases_count" field in this mutation.
func (m *TestPlanMutation) AddedPassedTestCasesCount() (r int32, exists bool) {
	v := m.addpassed_test_cases_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearPassedTestCasesCount clears the value of the "passed_test_cases_count" field.
func (m *TestPlanMutation) ClearPassedTestCasesCount() {
	m.passed_test_cases_count = nil
	m.addpassed_test_cases_count = nil
	m.clearedFields[testplan.FieldPassedTestCasesCount] = struct{}{}
}

// PassedTestCasesCountCleared returns if the "passed_test_cases_count" field was cleared in this mutation.
func (m *TestPlanMutation) PassedTestCasesCountCleared() bool {
	_, ok := m.clearedFields[testplan.FieldPassedTestCasesCount]
	return ok
}

// ResetPassedTestCasesCount resets all changes to the "passed_test_cases_count" field.
func (m *TestPlanMutation) ResetPassedTestCasesCount() {
	m.passed_test_cases_count = nil
	m.addpassed_test_cases_count = nil
	delete(m.clearedFields, testplan.FieldPassedTestCasesCount)
}

// SetSkippedTestCasesCount sets the "skipped_test_cases_count" field.
func (m *TestPlanMutation) SetSkippedTestCasesCount(u uint32) {
	m.skipped_test_cases_count = &u
	m.addskipped_test_cases_count = nil
}

// SkippedTestCasesCount returns the value of the "skipped_test_cases_count" field in the mutation.
func (m *TestPlanMutation) SkippedTestCasesCount() (r uint32, exists bool) {
	v := m.skipped_test_cases_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSkippedTestCasesCount returns the old "skipped_test_cases_count" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldSkippedTestCasesCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkippedTestCasesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkippedTestCasesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkippedTestCasesCount: %w", err)
	}
	return oldValue.SkippedTestCasesCount, nil
}

// AddSkippedTestCasesCount adds u to the "skipped_test_cases_count" field.
func (m *TestPlanMutation) AddSkippedTestCasesCount(u int32) {
	if m.addskipped_test_cases_count != nil {
		*m.addskipped_test_cases_count += u
	} else {
		m.addskipped_test_cases_count = &u
	}
}

// AddedSkippedTestCasesCount returns the value that was added to the "skipped_test_cases_count" field in this mutation.
func (m *TestPlanMutation) AddedSkippedTestCasesCount() (r int32, exists bool) {
	v := m.addskipped_test_cases_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearSkippedTestCasesCount clears the value of the "skipped_test_cases_count" field.
func (m *TestPlanMutation) ClearSkippedTestCasesCount() {
	m.skipped_test_cases_count = nil
	m.addskipped_test_cases_count = nil
	m.clearedFields[testplan.FieldSkippedTestCasesCount] = struct{}{}
}

// SkippedTestCasesCountCleared returns if the "skipped_test_cases_count" field was cleared in this mutation.
func (m *TestPlanMutation) SkippedTestCasesCountCleared() bool {
	_, ok := m.clearedFields[testplan.FieldSkippedTestCasesCount]
	return ok
}

// ResetSkippedTestCasesCount resets all changes to the "skipped_test_cases_count" field.
func (m *TestPlanMutation) ResetSkippedTestCasesCount() {
	m.skipped_test_cases_count = nil
	m.addskipped_test_cases_count = nil
	delete(m.clearedFields, testplan.FieldSkippedTestCasesCount)
}

// SetRunDuration sets the "run_duration" field.
func (m *TestPlanMutation) SetRunDuration(u uint32) {
	m.run_duration = &u
	m.addrun_duration = nil
}

// RunDuration returns the value of the "run_duration" field in the mutation.
func (m *TestPlanMutation) RunDuration() (r uint32, exists bool) {
	v := m.run_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldRunDuration returns the old "run_duration" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldRunDuration(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunDuration: %w", err)
	}
	return oldValue.RunDuration, nil
}

// AddRunDuration adds u to the "run_duration" field.
func (m *TestPlanMutation) AddRunDuration(u int32) {
	if m.addrun_duration != nil {
		*m.addrun_duration += u
	} else {
		m.addrun_duration = &u
	}
}

// AddedRunDuration returns the value that was added to the "run_duration" field in this mutation.
func (m *TestPlanMutation) AddedRunDuration() (r int32, exists bool) {
	v := m.addrun_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearRunDuration clears the value of the "run_duration" field.
func (m *TestPlanMutation) ClearRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	m.clearedFields[testplan.FieldRunDuration] = struct{}{}
}

// RunDurationCleared returns if the "run_duration" field was cleared in this mutation.
func (m *TestPlanMutation) RunDurationCleared() bool {
	_, ok := m.clearedFields[testplan.FieldRunDuration]
	return ok
}

// ResetRunDuration resets all changes to the "run_duration" field.
func (m *TestPlanMutation) ResetRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
	delete(m.clearedFields, testplan.FieldRunDuration)
}

// SetDeadline sets the "deadline" field.
func (m *TestPlanMutation) SetDeadline(u uint32) {
	m.deadline = &u
	m.adddeadline = nil
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *TestPlanMutation) Deadline() (r uint32, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldDeadline(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// AddDeadline adds u to the "deadline" field.
func (m *TestPlanMutation) AddDeadline(u int32) {
	if m.adddeadline != nil {
		*m.adddeadline += u
	} else {
		m.adddeadline = &u
	}
}

// AddedDeadline returns the value that was added to the "deadline" field in this mutation.
func (m *TestPlanMutation) AddedDeadline() (r int32, exists bool) {
	v := m.adddeadline
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeadline clears the value of the "deadline" field.
func (m *TestPlanMutation) ClearDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	m.clearedFields[testplan.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *TestPlanMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[testplan.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *TestPlanMutation) ResetDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	delete(m.clearedFields, testplan.FieldDeadline)
}

// SetTestResult sets the "test_result" field.
func (m *TestPlanMutation) SetTestResult(s string) {
	m.test_result = &s
}

// TestResult returns the value of the "test_result" field in the mutation.
func (m *TestPlanMutation) TestResult() (r string, exists bool) {
	v := m.test_result
	if v == nil {
		return
	}
	return *v, true
}

// OldTestResult returns the old "test_result" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldTestResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestResult: %w", err)
	}
	return oldValue.TestResult, nil
}

// ClearTestResult clears the value of the "test_result" field.
func (m *TestPlanMutation) ClearTestResult() {
	m.test_result = nil
	m.clearedFields[testplan.FieldTestResult] = struct{}{}
}

// TestResultCleared returns if the "test_result" field was cleared in this mutation.
func (m *TestPlanMutation) TestResultCleared() bool {
	_, ok := m.clearedFields[testplan.FieldTestResult]
	return ok
}

// ResetTestResult resets all changes to the "test_result" field.
func (m *TestPlanMutation) ResetTestResult() {
	m.test_result = nil
	delete(m.clearedFields, testplan.FieldTestResult)
}

// Where appends a list predicates to the TestPlanMutation builder.
func (m *TestPlanMutation) Where(ps ...predicate.TestPlan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestPlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestPlan).
func (m *TestPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestPlanMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, testplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testplan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, testplan.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, testplan.FieldName)
	}
	if m.state != nil {
		fields = append(fields, testplan.FieldState)
	}
	if m.owner_id != nil {
		fields = append(fields, testplan.FieldOwnerID)
	}
	if m.responsible_user_id != nil {
		fields = append(fields, testplan.FieldResponsibleUserID)
	}
	if m.failed_test_cases_count != nil {
		fields = append(fields, testplan.FieldFailedTestCasesCount)
	}
	if m.passed_test_cases_count != nil {
		fields = append(fields, testplan.FieldPassedTestCasesCount)
	}
	if m.skipped_test_cases_count != nil {
		fields = append(fields, testplan.FieldSkippedTestCasesCount)
	}
	if m.run_duration != nil {
		fields = append(fields, testplan.FieldRunDuration)
	}
	if m.deadline != nil {
		fields = append(fields, testplan.FieldDeadline)
	}
	if m.test_result != nil {
		fields = append(fields, testplan.FieldTestResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testplan.FieldCreatedAt:
		return m.CreatedAt()
	case testplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case testplan.FieldDeletedAt:
		return m.DeletedAt()
	case testplan.FieldName:
		return m.Name()
	case testplan.FieldState:
		return m.State()
	case testplan.FieldOwnerID:
		return m.OwnerID()
	case testplan.FieldResponsibleUserID:
		return m.ResponsibleUserID()
	case testplan.FieldFailedTestCasesCount:
		return m.FailedTestCasesCount()
	case testplan.FieldPassedTestCasesCount:
		return m.PassedTestCasesCount()
	case testplan.FieldSkippedTestCasesCount:
		return m.SkippedTestCasesCount()
	case testplan.FieldRunDuration:
		return m.RunDuration()
	case testplan.FieldDeadline:
		return m.Deadline()
	case testplan.FieldTestResult:
		return m.TestResult()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testplan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case testplan.FieldName:
		return m.OldName(ctx)
	case testplan.FieldState:
		return m.OldState(ctx)
	case testplan.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case testplan.FieldResponsibleUserID:
		return m.OldResponsibleUserID(ctx)
	case testplan.FieldFailedTestCasesCount:
		return m.OldFailedTestCasesCount(ctx)
	case testplan.FieldPassedTestCasesCount:
		return m.OldPassedTestCasesCount(ctx)
	case testplan.FieldSkippedTestCasesCount:
		return m.OldSkippedTestCasesCount(ctx)
	case testplan.FieldRunDuration:
		return m.OldRunDuration(ctx)
	case testplan.FieldDeadline:
		return m.OldDeadline(ctx)
	case testplan.FieldTestResult:
		return m.OldTestResult(ctx)
	}
	return nil, fmt.Errorf("unknown TestPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testplan.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testplan.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testplan.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case testplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testplan.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case testplan.FieldOwnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case testplan.FieldResponsibleUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibleUserID(v)
		return nil
	case testplan.FieldFailedTestCasesCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedTestCasesCount(v)
		return nil
	case testplan.FieldPassedTestCasesCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassedTestCasesCount(v)
		return nil
	case testplan.FieldSkippedTestCasesCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkippedTestCasesCount(v)
		return nil
	case testplan.FieldRunDuration:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunDuration(v)
		return nil
	case testplan.FieldDeadline:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case testplan.FieldTestResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestResult(v)
		return nil
	}
	return fmt.Errorf("unknown TestPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestPlanMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, testplan.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, testplan.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, testplan.FieldDeletedAt)
	}
	if m.addfailed_test_cases_count != nil {
		fields = append(fields, testplan.FieldFailedTestCasesCount)
	}
	if m.addpassed_test_cases_count != nil {
		fields = append(fields, testplan.FieldPassedTestCasesCount)
	}
	if m.addskipped_test_cases_count != nil {
		fields = append(fields, testplan.FieldSkippedTestCasesCount)
	}
	if m.addrun_duration != nil {
		fields = append(fields, testplan.FieldRunDuration)
	}
	if m.adddeadline != nil {
		fields = append(fields, testplan.FieldDeadline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testplan.FieldCreatedAt:
		return m.AddedCreatedAt()
	case testplan.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case testplan.FieldDeletedAt:
		return m.AddedDeletedAt()
	case testplan.FieldFailedTestCasesCount:
		return m.AddedFailedTestCasesCount()
	case testplan.FieldPassedTestCasesCount:
		return m.AddedPassedTestCasesCount()
	case testplan.FieldSkippedTestCasesCount:
		return m.AddedSkippedTestCasesCount()
	case testplan.FieldRunDuration:
		return m.AddedRunDuration()
	case testplan.FieldDeadline:
		return m.AddedDeadline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testplan.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case testplan.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case testplan.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case testplan.FieldFailedTestCasesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedTestCasesCount(v)
		return nil
	case testplan.FieldPassedTestCasesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassedTestCasesCount(v)
		return nil
	case testplan.FieldSkippedTestCasesCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkippedTestCasesCount(v)
		return nil
	case testplan.FieldRunDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunDuration(v)
		return nil
	case testplan.FieldDeadline:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadline(v)
		return nil
	}
	return fmt.Errorf("unknown TestPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testplan.FieldName) {
		fields = append(fields, testplan.FieldName)
	}
	if m.FieldCleared(testplan.FieldState) {
		fields = append(fields, testplan.FieldState)
	}
	if m.FieldCleared(testplan.FieldOwnerID) {
		fields = append(fields, testplan.FieldOwnerID)
	}
	if m.FieldCleared(testplan.FieldResponsibleUserID) {
		fields = append(fields, testplan.FieldResponsibleUserID)
	}
	if m.FieldCleared(testplan.FieldFailedTestCasesCount) {
		fields = append(fields, testplan.FieldFailedTestCasesCount)
	}
	if m.FieldCleared(testplan.FieldPassedTestCasesCount) {
		fields = append(fields, testplan.FieldPassedTestCasesCount)
	}
	if m.FieldCleared(testplan.FieldSkippedTestCasesCount) {
		fields = append(fields, testplan.FieldSkippedTestCasesCount)
	}
	if m.FieldCleared(testplan.FieldRunDuration) {
		fields = append(fields, testplan.FieldRunDuration)
	}
	if m.FieldCleared(testplan.FieldDeadline) {
		fields = append(fields, testplan.FieldDeadline)
	}
	if m.FieldCleared(testplan.FieldTestResult) {
		fields = append(fields, testplan.FieldTestResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestPlanMutation) ClearField(name string) error {
	switch name {
	case testplan.FieldName:
		m.ClearName()
		return nil
	case testplan.FieldState:
		m.ClearState()
		return nil
	case testplan.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case testplan.FieldResponsibleUserID:
		m.ClearResponsibleUserID()
		return nil
	case testplan.FieldFailedTestCasesCount:
		m.ClearFailedTestCasesCount()
		return nil
	case testplan.FieldPassedTestCasesCount:
		m.ClearPassedTestCasesCount()
		return nil
	case testplan.FieldSkippedTestCasesCount:
		m.ClearSkippedTestCasesCount()
		return nil
	case testplan.FieldRunDuration:
		m.ClearRunDuration()
		return nil
	case testplan.FieldDeadline:
		m.ClearDeadline()
		return nil
	case testplan.FieldTestResult:
		m.ClearTestResult()
		return nil
	}
	return fmt.Errorf("unknown TestPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestPlanMutation) ResetField(name string) error {
	switch name {
	case testplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testplan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case testplan.FieldName:
		m.ResetName()
		return nil
	case testplan.FieldState:
		m.ResetState()
		return nil
	case testplan.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case testplan.FieldResponsibleUserID:
		m.ResetResponsibleUserID()
		return nil
	case testplan.FieldFailedTestCasesCount:
		m.ResetFailedTestCasesCount()
		return nil
	case testplan.FieldPassedTestCasesCount:
		m.ResetPassedTestCasesCount()
		return nil
	case testplan.FieldSkippedTestCasesCount:
		m.ResetSkippedTestCasesCount()
		return nil
	case testplan.FieldRunDuration:
		m.ResetRunDuration()
		return nil
	case testplan.FieldDeadline:
		m.ResetDeadline()
		return nil
	case testplan.FieldTestResult:
		m.ResetTestResult()
		return nil
	}
	return fmt.Errorf("unknown TestPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestPlanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestPlanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestPlanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestPlanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestPlanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestPlan edge %s", name)
}
